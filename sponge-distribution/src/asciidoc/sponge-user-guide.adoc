= User Guide
:page-permalink: /user-guide/
:toc:
:pySourcesUrl: {sourcesUrl}/sponge-jython/examples/script/py/
:rbSourcesUrl: {sourcesUrl}/sponge-jruby/examples/script/rb/
:groovySourcesUrl: {sourcesUrl}/sponge-groovy/examples/script/groovy/
:jsSourcesUrl: {sourcesUrl}/sponge-nashorn/examples/script/js/
:coreSourcesUrl: {sourcesUrl}/sponge-integration-tests/examples/core/
:springSourcesUrl: {sourcesUrl}/sponge-spring/examples/spring/
:camelSourcesUrl: {sourcesUrl}/sponge-camel/examples/camel/
:py4jSourcesUrl: {sourcesUrl}/sponge-py4j/examples/py4j/
:midiSourcesUrl: {sourcesUrl}/sponge-midi/examples/midi/
:tensorflowSourcesUrl: {sourcesUrl}/sponge-tensorflow/examples/tensorflow/

== Introduction
{sponge} is a polyglot system that allows creating knowledge bases in several scripting languages.

For the purpose of clarity, examples in this chapter are written in Python (http://www.jython.org[Jython]) as one of the supported scripting languages and in Java. All examples written in Python may have equivalent ones written in any of the other <<supported-script-languages,supported script languages>>.


include::includes/user-guide-architecture.adoc[leveloffset=+1]


include::includes/user-guide-configuration.adoc[leveloffset=+1]

== Engine

=== Starting up
To startup the engine you should invoke the `startup()` method. After startup, the engine runs in the background (i.e. using threads other than the current one) until you shutdown it.

.Example of starting up
[source,java]
----
SpongeEngine engine = DefaultSpongeEngine.builder().config("examples/script/py/triggers_hello_world.xml").build();
engine.startup();
----

=== Shutting down
When a {sponge} instance is no longer needed it should be shut down by invoking `shutdown()` or `requestShutdown()` method. It instructs the engine to do some clean up, stop all managed threads, free resources, etc. The `shutdown()` uses the current thread to stop the engine. The `requestShutdown()` uses a new thread to stop the engine, thus allowing to shutdown the engine from the within, e.g. form an event processor.

.Example of shutting down in Java
[source,java]
----
engine.shutdown();
----

.Example of shutting down in a script language
[source,python]
----
class SomeTrigger(Trigger):
    def onConfigure(self):
        self.withEvent("e1")
    def onRun(self, event):
        sponge.requestShutdown()
----

Shutting down doesn't guarantee that all events sent to the engine will be processed. However, all events that have already been read from the Input Event Queue (by the Filter Processing Unit) will be fully processed by the engine, if the processing doesn't exceed shutdown timeouts (specified by the `executorShutdownTimeout` configuration parameter). All newer events remaining in the Input Event Queue will not be processed at all.

include::includes/user-guide-knowledge-bases.adoc[leveloffset=+1]

[[types]]
== Data types

=== Supported data types
Data types are represented by instances of classes. The type classes are located in the `org.openksavi.sponge.type` package. Types are used for example as action arguments and result metadata.

.Basic type properties
[cols="1,3"]
|===
|Property |Description

|`name`
|A type location name. It is required if a type is used to specify an action argument metadata. In that case a type name is a name of an action argument. It is also required if a type is used to specify a record type field. A type location name has to be set in a type constructor.

|`label`
|An optional type location label. For example an action argument label or a record field label.

|`description`
|An optional type location description.

|`annotated`
|A flag that tells if a value of this type is annotated. Defaults to `false`.

|`format`
|An optional format.

|`defaultValue`
|An optional default value. A default value for an annotated type must be wrapped in an `AnnotatedValue(value)`.

|`nullable`
|Tells if a value of this type can be `null`. The default is that a value must not be null, i.e. it is *not nullable*.

|`features` (or `feature`)
|Optional features as a map of names to values (as the `Object` type).

|`optional`
|A flag specifying if a value in a location corresponding to this type is optional. Defaults to `false`. It is used in action arguments.

|`provided`
|The _provided_ type specification as an instance of the `ProvidedMeta` class. Defaults to `null`. A provided value has to be an instance of `ProvidedValue`.
|===

A type properties should be set using the builder-style methods, e.g. `StringType("id").withLabel("Identifier")`.

.Provided type specification properties
[cols="1,3"]
|===
|Property |Description

|`value`
|A flag specifying if this type value is provided.

|`valueSet`
|Metadata specifying if a value set is provided. Defaults to `null`. A value set is a list of allowed values. This list of values may be limited (the default setting) or not limited. A limited set means that the type value can be chosen only from the value set. To configure a not limited value set use `withValueSet(ValueSetMeta().withNotLimited())`.

|`elementValueSet`
|A flag specifying if the list element value set is provided. Applicable only for list types. Defaults to `false`. Along with `ListType.unique` it can represent multichoice.

|`depends`
|A list of type names of name paths that this type depends on.

|`readOnly`
|A flag specifying if this type is read only. Defaults to `false`.

|`overwrite`
|A flag specifying if the provided value of this type should overwrite a value modified in a client code (in most cases by a user). Defaults to `false`. This flag should be handled by a client code.

|`submittable`
|A metadata specifying if a value can be submitted (i.e. written ad hoc), for example in an action, irrespectively of an action call.

|`lazyUpdate`
|A flag specifying if a provided value should be updated lazily in a client code when a dependency changes. This flag is experimental.

|`current`
|A flag specifying if a current value in a client code should be passed to a server when its new value is to be provided.

|`mode`
|A provided read mode: `explicit` (a value has to specified to be provided in `provideArgs`), `optional` (a value may or may not be specified to be provided in `provideArgs`) or `implicit` (a value shouldn't be specified to be provided in `provideArgs`). Defaults to `explicit`. For example a value can be provided optionally or implicitly when an other value is submitted. To set this property to a value other than a default, use the `withOptionalMode()` or the `withImplicitMode()` method.
|===

.Submittable metadata properties
[cols="1,3"]
|===
|Property |Description

|`influences`
|A list of object names that a submitted object influences (i.e. can change their values when submitted).
|===

See the <<provided_arguments,provided action arguments>> as a use case of provided types.

.Data types
[cols="1,5"]
|===
|Type |Description

|`AnyType`
|An any type. It may be used in situations when type is not important.

|`BinaryType`
|A binary (byte array) type. Provides an optional property `mimeType`.

|`BooleanType`
|A boolean type.

|`DateTimeType`
|A date/time type. This type requires a `DateTimeKind` parameter, which is is an enumeration of `DATE_TIME` (a value of this type in Java has to be an instance of `LocalDateTime`), `DATE_TIME_ZONE` (an instance of `ZonedDateTime`), `DATE` (an instance of `LocalDate`), `TIME` (an instance of `LocalTime`), `INSTANT` (an instance of `Instant`). To ensure interoperability with other systems, defining a type format (especially for `DATE` and `TIME`) is recommended and in some cases required. A type format uses the ICU/JDK date/time pattern specification. The {sponge} REST API uses a type format (if defined) to serialize a value of `DateTimeType` to JSON. The default date/time kind is `DATE_TIME`.

|`DynamicType`
|An dynamic type representing dynamically typed values. A value of this type has to be an instance of `DynamicValue`.

|`IntegerType`
|An integer type (commonly used integer type or long). Provides optional properties `minValue`, `maxValue`, `exclusiveMin` and `exclusiveMax`, e.g.: `IntegerType().withMinValue(1).withMinValue(100)`.

|`ListType`
|A list type. This type requires a `DataType` parameter, which is is a type of list elements. Provides optional property `unique` specifying if the list should contain unique values (defaults to `false`). For example: `ListType().withElement(ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject"))`.

|`MapType`
|A map type. This type requires two `DataType` parameters: a type of keys and a type of values in the map. For example: `MapType().withKey(StringType()).withValue(ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject"))`.

|`NumberType`
|A number type, that include both integer and floating-point numbers. Provides optional properties `minValue`, `maxValue`, `exclusiveMin` and `exclusiveMax`, e.g.: `NumberType()`.

|`ObjectType`
|An object. This type requires a class name (typically a Java class name). For example: `ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject")`. It also supports an array notation: `ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject[]")`. There is a convenience method `withClass(Class)` as well. An object type can have a companion type that provides metadata to a client code, e.g. `ObjectType().withClass(CustomObject).withCompanionType(RecordType()...)`.

|`RecordType`
|A record type. This type requires a list of named record field types. A value of this type has to be an instance of Map with elements corresponding to the field names and values. E.g.: `RecordType("book").withFields([StringType("author").withLabel("Author"), StringType("title").withLabel("Title")])`. A record type supports inheritance.

|`StreamType`
|A stream type. Supports only output streams. It can be used only as a result of an action. A value of this type has to be an instance of `OutputStreamValue`.

|`StringType`
|A string type. Provides optional properties `minLength` and `maxLength`, e.g.: `StringType().withMaxLength(10)`.

|`TypeType`
|A type representing a data type. A value of this type has to be an instance of `DataType`.

|`VoidType`
|A void type that may be used to specify that an action returns no result.
|===

.Type examples
[source,python]
----
StringType().withMaxLength(10).withFormat("ipAddress")
StringType("ip").withMaxLength(10).withFormat("ipAddress")
IntegerType().withMinValue(1).withMaxValue(100).withDefaultValue(50)
AnyType().withNullable(True)
ListType(StringType())
ListType(ObjectType().withClassName("java.math.BigDecimal"))
ObjectType().withClassName("java.lang.String[]")
ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject")
ListType(ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject"))
BinaryType().withMimeType("image/png").withFeatures({"width":28, "height":28, "color":"white"})
OutputStreamValue(lambda output: IOUtils.write("Sample text file\n", output, "UTF-8")).withContentType("text/plain; charset=\"UTF-8\"").withHeaders({})
----

=== Registering data types
A data type can be registered in the engine in order to be accessed later by its registered type name.

.Engine facade methods for registered types
[cols="1,3"]
|===
|Method |Description

|`addType(String registeredTypeName, DataTypeSupplier<T> typeSupplier)`
|Registers a data type by providing a type supplier that will create a new instance of the registered type each time, e.g. `sponge.addType("Author", lambda: RecordType([StringType("firstName").withLabel("First name"), StringType("surname").withLabel("Surname")]))`.

|`getType(String registeredTypeName)`
|Returns a new instance of the registered data type.

|`getType(String registeredTypeName, String locationName)`
|Returns a new instance of the registered data type setting the returned type location name as well.

|`Map<String, DataType> getTypes()`
|Returns the unmodifiable map of registered data types.
|===

Data types should be registered in the `onBeforeLoad`, because it is invoked before scanning processors.

.The registered data type example
[source,python]
----
def onBeforeLoad():
    sponge.addType("Author", lambda: RecordType([
                StringType("firstName").withLabel("First name"),
                StringType("surname").withLabel("Surname")
            ]))
    sponge.addType("Book", lambda: RecordType([
                sponge.getType("Author", "author").withLabel("Author"),
                StringType("title").withLabel("Title")
            ]))

class GetBookAuthorSurname(Action):
    def onConfigure(self):
        self.withLabel("Get a book author").withArg(sponge.getType("Book").withName("book")).withResult(sponge.getType("Author"))
    def onCall(self, book):
        return book["author"]["surname"]
----

=== Record type inheritance
A record type supports inheritance by setting its base type. Fields in a base type can't be overwritten in a sub-type. Other record type properties are merged. Properties in a sub-type take precedence if they are not set to default values.

.The record inheritance example
[source,python]
----
def onBeforeLoad():
    sponge.addType("Person", lambda: RecordType().withFields([
        StringType("firstName").withLabel("First name"),
        StringType("surname").withLabel("Surname")
    ]))
    sponge.addType("Citizen", lambda: RecordType().withBaseType(sponge.getType("Person")).withFields([
        StringType("country").withLabel("Country")
    ]))
----

=== Annotated values
Annotated values are wrapped by an instance of the `AnnotatedValue` class. An annotated value allows passing a value label, a value description, features, type label and type description along with the value, e.g. `AnnotatedValue(imageBytes).withValueLabel("Image1").withFeatures({"filename":imageFilename})`, where the first property is the annotated value, the second is the value label and the third is the features map that may be used in a client code.

Annotated values can be used to alter a static, metadata-drived behavior of a client application. For example they are especially useful as provided action argument values that carry additional, dynamic data as features.

.Annotated value properties
[cols="1,3"]
|===
|Property |Description

|`value`
|A value that is annotated.

|`valueLabel`
|An optional value label. It can be used as a string representation of the value in a GUI.

|`valueDescription`
|An optional value description. It can be used as a description of the value in a GUI.

|`features`
|Features as a map of names to values.

|`typeLabel`
|An optional type label. Overwrites the type label in a client code.

|`typeDescription`
|An optional type description. Overwrites the type description in a client code.
|===

If a data type is annotated and has a default value, the default value should be wrapped in an `AnnotatedValue`.

=== Object type companion type
Limitations:

* Conversion between a companion type value and an object type value is supported only in the {sponge} REST API.
* Loops in nested data types are not supported.
* Object inheritance is not supported (if a companion type is a record type).
* A companion type is not validated against the object type class.

== Features
Features are represented by a map of names to values. They provide additional information to data types, processors and other entities. They are flexible in a sense that they are not a part of the static API. The predefined features are listed in the {sourcesUrl}/sponge-features/src/main/java/org/openksavi/sponge/features/Features.java[`Features.java`].

Features can be used in a client code to provide customized behavior.

A feature can have a _feature converter_ registered for its name. The converter is used by the REST API. It allows to use complex feature values in knowledge bases (e.g. `"icon":IconInfo("home").withColor("FF0000").withSize(50)`) that will be marshalled and unmarshalled to and from JSON. If a feature has a converter, all usages of this feature will have to conform to a feature type supported by the converter (e.g. the `"icon"` feature converter supports an instance of `IconInfo` or `String` as a value).

If a feature is used in events, its values should be `Serializable`.

== Events
Events are the basic element of processing in {sponge}. They have properties such as id, name and send time. The name of an event is also the type of this event. All events than have the same name belong to the same type. Event names should follow Java naming conventions for variable names. Events may have any number of attributes. These attributes will be available, for example, in event processors.

{sponge} supports only point-in-time events.

=== Properties and methods

.Event properties and methods
[cols="1,4"]
|===
|Property / Method |Description

|`id`
|A property that is a global unique identifier of an event (String). This is a shortcut for `getId()`/`setId(text)` methods.

|`name`
|A read-only property that is the name (type) of an event. This is a shortcut for the `getName()` method. A name of an event shouldn't be changed after the event has been created. A name must not be empty nor contain white spaces or reserved characters (`:`). You should also avoid using names that are regular expressions.

|`time`
|A property that is a send time of an event, i.e. a time of adding an event to the Input Event Queue. The time is represented as `java.time.Instant`. This is a shortcut for `getTime()`/`setTime(instant)` methods.

|`label`
|An optional event label.

|`description`
|An optional event description.

|`set(attributeName, value)`
|A method that allows setting an attribute of an event.

|`Object get(attributeName)`
|A method that returns a value of an attribute or throws `IllegalArgumentException` if it does't exist.

|`Object get(attributeClass, attributeName)`
|A method that returns a value of an attribute (assuming it is an instance of `attributeClass`) or throws `IllegalArgumentException` if it does't exist.

|`Object get(attributeName, defaultValue)`
|A method that returns a value of an attribute or `defaultValue` if it does't exist.

|`boolean has(attributeName)`
|A method that checks if an event has an attribute.

|`all`
|A property that returns a map of all attributes. This is a shortcut for the `getAll()` method.

|`Map<String, Object> features`
|Event features.

|`Event clone()`
|A method that clones an event.
|===

Properties `id` and `time` are automatically set when adding an event to the Input Event Queue and there is no need for setting them manually.

=== Typical event processing
In order to process an event there must be an event processor listening to events of that type (the types of events are recognized by their names). So this steps should be taken:

* Creating an event processor.
* Enabling the event processor automatically or manually (by invoking a proper `sponge.enable*()` method).
* Creating a new event instance and sending it to the system (e.g. `sponge.event("alarm").set("location", "Building 1").send()`.
* The event goes directly to the Input Event Queue or is scheduled to be inserted to the Input Event Queue later. Scheduling is performed by the Event Scheduler.
* From this queue the events are taken by the Filter Processing Unit. The list of filters defined for this event type is taken and then each of them is invoked. If all filters accept the event, it will be put to the Main Event Queue in which it will await to be processed by other event processors.
* Then the event is collected by the Main Processing Unit. The list of event processors listening to this type of events is selected and then each of them is given the event to process.
* After processing by the Main Processing Unit the event goes to the Output Event Queue if and only if it hasn't been processed (i.e. listened to) by any of event processors.

=== Event cloning
The event is cloned each time when the periodically generated events are sent to the Input Event Queue.

The standard implementation of events allows choosing the cloning policy `shallow` or `deep`. These policies differ in the way of cloning of events attributes. When using the former, the references to attributes are copied - each event processor works on the same attribute instances. The policy `deep` executes the procedure of deep cloning, so each next generated event will contain individual copies of the attributes.

=== Custom events
The default implementation of an event is the `AttributeMapEvent` class. However, {sponge} allows to use custom event implementations of the `Event` interface.

=== System events
System events are sent automatically by the engine. An event sent in your code shouldn't have the same name as any of the system events. Currently there is only one system event.

.System events
[cols="1,4"]
|===
|Event name |Description

|`startup`
|The `startup` event will be sent as the first event when the engine is starting up.
|===

==== Startup system event
The `startup` system event could be useful to define rules or correlators that detect lack of other events since the startup of the engine.

The following rule detects a situation when there is no `heartbeat` event for `5` seconds since the startup of {sponge}.

.Example of startup system event
[source,python]
----
class DetectLackOfHearbeat(Rule):
    def onConfigure(self):
        self.withEvents(["startup", "heartbeat :none"]).withDuration(Duration.ofSeconds(5))
    def onRun(self, event):
        print "No heartbeat!"
----

=== Control events
Control events are used by the engine internally. The names of control events have a prefix `$`. You shouldn't give to your events a name that starts with this character.

=== Creating and sending events
*Creating an event means creating an instance of an event class. Sending an event means that the created event will be put into the Input Event Queue, to be processed by filters and then by triggers, rules and correlators.*

Event can be created and sent using the EventDefinition fluent API (e.g. `sponge.event("helloEvent").set("say", "Hello World!").send()`). The method `sponge.event` returns `EventDefinition`.

An event may be sent as:

* A single instance – the event will be placed in the Input Event Queue only once.
* Many instances periodically – new instances of an event will be placed in the Input Event Queue periodically, each of them with its own id and send time.

.`EventDefinition` methods
[cols="1,4"]
|===
|Method |Description

|`EventDefinition set(String name, Object value)`
|Sets the event attribute.

|`EventDefinition feature(String name, Object value)`
|Add an event feature.

|`EventDefinition features(Map<String, Object> features)`
|Add event features.

|`EventDefinition modify(EventDefinitionModifier modifier)`
|Modifies the underlying event.

|`send()`
|Sends an event immediately.

|`sendAfter(delay)`
|Sends an event after a specified time (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]). Note that the order of inserting events to the Input Event Queue may be different than the order of invocations of `sendAfter`, even with the same `delay`. It depends on the internal implementation of the Quartz library.

|`sendAfter(delay, interval)`
|Periodically sends events after a specified time (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]) every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`sendAt(at)`
|Sends an event at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970 or as an {javaSeJavaDocUrl}/java/time/Instant.html[`Instant`]).

|`sendAt(at, interval)`
|Periodically sends events starting at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970 or as an {javaSeJavaDocUrl}/java/time/Instant.html[`Instant`]) every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`sendAt(crontabSpec)`
|Sends events at time specified by Cron compatible time entry.

|`sendEvery(interval)`
|Periodically sends events every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`Event make()`
|Only returns the newly created event without sending.
|===

=== Examples of sending events
Sample sending of events from the level of a knowledge base:

[source,python]
----
sponge.event("e1").sendAfter(Duration.ofSeconds(1))
----
Sends the event named `"e1"` after `1` second from now.

[source,python]
----
sponge.event("e2").sendAfter(2000, 1000)
----
Sends the event named `"e2"` after `2` seconds from now. New events will be periodically generated and sent every second.

[source,python]
----
sponge.event("e2").set("color", "red").set("severity", 5).send()
----
Sends an event with attributes `"color"` and `"severity"` immediately.

[source,python]
----
sponge.event("alarm").sendAt("0-59 * * * * ?")
----
Sends an event at the time specified by Cron notation.

=== Registered event types
Event type may be registered in the engine. The registered event type is a `RecordType` that describes event attributes. The name of an event instance is also a registration name of a registered event type. Event types are are not verified by the engine but could be interpreted by a client code or {sponge} plugins. For example they could be useful in a generic GUI that sends or subscribes to events.

.Example of registering event types
[source,python]
----
def onBeforeLoad():
    sponge.addEventType("notification", RecordType().withFields([
        StringType("source").withLabel("Source"),
        IntegerType("severity").withLabel("Severity").withNullable()
    ]).withLabel("Notification"))

def onStartup():
    sponge.event("notification").set({"source":"Sponge", "severity":10}).label("The notification").description("The new event notification").send()
----

=== Event priorities
A priority may be assigned only to control events, that are used internally by the engine. For standard events the priority always equals to `0` and cannot be modified.

A priority defines a level of the importance of an event. Events are added to and taken from queues with respect to their priorities. Priority is a positive or negative integer and the higher the number is, the higher is the priority of an event and the event will be processed before the others.

== Processors
Processors are the basic objects that you define in {sponge} to implement your knowledge base behavior.

Types of processors:

* *Actions* - processors that provide functionality similar to functions. They don't listen to events.
* *Event processors* - processors that perform specified operations using events they listen to.
** *Filters* - event processors used for allowing only certain events to be later processed by other event processors.
** *Triggers* -  event processors that execute a specified code when an event happens.
** *Event set processors* - event processors that process sets of events.
*** *Rules* - event set processors that detect sequences of events.
*** *Correlators* - event set processors that detect any set of events and could be also used for implementing any complex event processing that isn't provided by filters, triggers or rules.

A processors can be defined by a class or by a processor builder.

=== Processors defined by classes

==== Definition
In order to define your processor in a script knowledge base, you have to create a class extending the base class pointed by a specific alias (e.g. `Filter` for filters). In order to define your processor in a Java knowledge base, you have to create a class extending a specific class (e.g. `JFilter` for filters).

A name of a processor is a name of a class defining this processor.

==== Enabling
The operation of registering a processor in the engine is called enabling. Registered processors are available to the engine to perform specific tasks. For example, after enabling an event processor starts listening to events it is interested in.

Processors could be enabled:

* by auto-enable (this is the default setting for script-based processors),
* manually.

===== Auto-enable
{sponge} automatically enables all processors (i.e. actions, filters, triggers, rules and correlators) defined as classes in a script knowledge base. This is done just before invoking the `onLoad` callback function in the knowledge base. Processor classes whose names start with the `Abstract` prefix are considered abstract and will not be automatically enabled.

Enabling Java-based processors has to be done manually.

For non script knowledge bases (Java or Kotlin based) the auto-enable feature will scan only for processor classes nested in a corresponding knowledge base class. Other processors have to be enabled manually.

.Example of processor inheritance and auto-enable
[source,python]
----
# This abstract action will not be automatically enabled.
class AbstractCalculateAction(Action):
    def calculateResult(self):
        return 1

# This action will be automatically enabled.
class CalculateAction(AbstractCalculateAction):
    def onCall(self):
        return self.calculateResult() * 2
----

You may turn off auto-enable by setting the `autoEnable` engine configuration parameter to `false` (for example in the Sponge XML configuration file). In that case you have to enable processors manually.

===== Manual enabling
In most cases enabling processors manually should be done in the `onLoad` callback function.

To manually enable any script-based processors in a script knowledge base you may use: `sponge.enable()` to enable one processor and `sponge.enableAll()` to enable many processors.

.Example of enabling a script-based processor
[source,python]
----
def onLoad:
    sponge.enable(TriggerA)
----

.Example of enabling script-based processors
[source,python]
----
def onLoad:
    sponge.enableAll(Trigger1, Trigger3)
----

To manually enable any Java-based processors in a script knowledge base you may use `sponge.enableJava()`, `sponge.enableJavaAll()` or `sponge.enableJavaByScan()`. The default name of a Java-based processor is its full Java class name.

The `enableJavaByScan` method enables Java-based processors by scanning a given packages in search of all non abstract processor classes. The scanning is performed by the https://github.com/ronmamo/reflections[Reflections] library. The method parameters are compatible with the http://ronmamo.github.io/reflections/index.html?org/reflections/Reflections.html[`Reflections(Object...)`] constructor.

.Example of enabling one Java-based processor
[source,python]
----
def onLoad():
    sponge.enableJava(SameSourceJavaRule)
----

.Example of enabling many Java-based processors
[source,python]
----
def onLoad():
    sponge.enableJavaAll(SameSourceJavaRule, SameSourceJavaRule2, SameSourceJavaRule3)
----

.Example of enabling Java-based processors by scanning Java packages
[source,python]
----
def onLoad():
    sponge.enableJavaByScan("org.openksavi.sponge.integration.tests.core.scanning")
----

==== Disabling
Processors can be disabled only manually. To disable any script-based processors in a script knowledge base you may use `sponge.disable()` to disable one processor and `sponge.disableAll()` to disable many processors.

.Example of disabling a script-based processor
[source,python]
----
def onLoad:
    sponge.disable(EchoAction)
----

To disable any Java-based processors in a script knowledge base you may use `sponge.disableJava()`, `sponge.disableJavaAll()` or `sponge.disableJavaByScan()`.

.Example of disabling a Java-based processor
[source,python]
----
def onLoad():
    sponge.disableJava(SameSourceJavaRule)
----

Any processor can be disabled by its name.

.Example of disabling a processor by its name
[source,python]
----
sponge.disable("EchoAction")
----

=== Processors defined by processor builders
In order to define your processor by a processor builder you have to configure it using a builder fluter API and manually enable in the engine. A name of a processor is a text passed to a builder constructor.

.Definition and enabling an action using a builder
[source,python]
----
def onLoad:
    sponge.enable(ActionBuilder("HelloWorldAction").withOnCall(lambda action, name: "Hello World! Hello {}!".format(name)))
----

A processor defined by a processor builder can be disabled by its name.

=== Properties and methods

[[processor-methods]]
.Processor properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|*`onConfigure()`*
|The configuration callback method that will be invoked when a processor is being enabled. This method is mandatory for processors defined as classes.

|`onInit()`
|The initialization callback method that will be invoked after `onConfigure()`, each time a new working instance of the processor is created.

|`withName(String name)`
|Sets a processor name. The name can be read using `self.meta.name`. Because names of processors are created automatically, this method shouldn't be invoked directly.

|`withLabel(String label)`
|Sets a processor label. The label can be read using `self.meta.label`. A label is not used internally but could be useful in a client code.

|`withDescription(String description)`
|Sets a processor description. The description can be read using `self.meta.description`. A description is not used internally but could be useful in a client code.

|`withVersion(Integer version)`
|Sets a processor version. The version can be read using `self.meta.version`. A version is not used internally by the engine. However it is used to enforce version checking when calling actions via the REST API.

|`withFeatures(Map<String, Object> features)`
|Adds processor features. The features can be read using `self.meta.features`. The processor features is simply a map of String to Object associated with a processor definition (not instance). It could be used to provide a custom behavior in a client code.

|`withFeature(String name, Object value)`
|Adds a single processor feature.

|`withCategory(String category)`
|Sets a processor category. The category can be read using `self.meta.category`. A category is not used internally but could be useful in a client code.

|`meta`
|The read-only property that provides a processor metadata.

|`logger`
|The read-only property that provides a processor logger. This is a shortcut for `getLogger()` method. A processor logger name has the following format: `sponge.kb.<language>.<knowledgeBaseName>.<processorName>`, e.g. `sponge.kb.python.kb1.EchoAction` for a python-based processor, `sponge.kb.python.kb1.org.openksavi.sponge.examples.PowerEchoAction` for a Java-based processor enabled in a Python-based knowledge base.

|`adapter`
|The read-only property that provides a processor adapter. This is a shortcut for `getAdapter()` method. A processor adapter is an internal object, associated with the processor, that is used by the engine. There should be no need to use this property in the client code.
|===

Processors provide builder-style, fluent methods to set metadata properties, e.g. `self.withLabel("Label").withDescription("Description")`. In many scripting languages properties can be accessed using a dot notation rather than a direct method call. For example a processor metadata may be read using `self.meta` or `self.getMeta()`.

.Processor builder specific properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`withOnInit(ProcessorOnInitCallback onInitCallback)`
|Configures the `onInit()` callback function that accepts one argument - the processor instance, e.g. `withOnInit(lambda action: sponge.setVariable("v1", True))`.
|===

include::includes/user-guide-actions.adoc[leveloffset=+1]

include::includes/user-guide-event-processors.adoc[leveloffset=+1]

include::includes/user-guide-event-processors-filters.adoc[leveloffset=+1]

include::includes/user-guide-event-processors-triggers.adoc[leveloffset=+1]

include::includes/user-guide-event-processors-rules.adoc[leveloffset=+1]

include::includes/user-guide-event-processors-correlators.adoc[leveloffset=+1]

== Plugins
Plugins are used for expanding {sponge} with new functionalities and use them in knowledge bases. Typically they provide access to and from external systems.

The alias for the base class for script-based plugins is `Plugin`. The base class for Java-based plugins is `JPlugin`.

Each of these base classes extends the `BasePlugin` class that provides empty implementations of callback methods. If the created plugin requires own configuration parameters (e.g. in the XML configuration file) the `onConfigure` method should be implemented.

Each plugin is also an engine module and that means that in inherits from the `BaseEngineModule` class.

Plugins could be written in Java or in a supported scripting language as a part of a scripting knowledge base. However plugins written in a scripting language must be used only in the same scripting knowledge base they were defined in. That is because there are limitations of scripting languages interoperation. Only plugins written in Java could be used in any scripting knowledge base.

=== Properties and methods

.Plugin properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`name`
|The property that is a name of a plugin. This is a shortcut for `getName()`/`setName(text)` methods. Because of names of plugins are created automatically, the setter shouldn't be used in a client code.

|`onConfigure(Configuration configuration)`
|The configuration callback method that will be invoked after a plugin has been loaded. This method allows reading an XML configuration for the plugin.

|`onInit()`
|The initialization callback method that will be invoked after a configuration of a plugin.

|`onStartup()`
|The callback method that will be invoked once after the startup of the engine.

|`onShutdown()`
|The callback method that will be invoked once before the shutdown of the engine.

|`onBeforeReload()`
|The callback method that will be invoked before every reloading of a knowledge base.

|`onAfterReload()`
|The callback method that will be invoked after every reloading of a knowledge base.

|`logger`
|The read-only property that provides a plugin logger. This is a shortcut for `getLogger()` method. A plugin logger name has the following format: `sponge.kb.plugin.<pluginName>`. Example logger name: `sponge.kb.plugin.scriptPlugin`.
|===

[discrete]
=== Example in Java

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="https://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://sponge.openksavi.org https://sponge.openksavi.org/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase">
            <file>plugins_java.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="echoPlugin" class="org.openksavi.sponge.examples.EchoPlugin">
            <configuration>
                <echo>Echo test!</echo>
                <count>2</count>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

This plugin definition section contains:

* The unique name of the plugin. This name may be used in knowledge bases as a variable referencing this plugin instance.
* The class name of the plugin. It could be a Java class name or a scripting language class name. If the plugin is defined in a scripting knowledge base than you must specify that knowledge base name as an XML tag `<knowledgeBaseName>`.
* Custom configuration for a plugin. That section could be any XML that is understood by this plugin.

The above configuration defines a plugin implemented by `org.openksavi.sponge.examples.EchoPlugin` class. This plugin may be used in the knowledge base as a global variable named `echoPlugin` (according to the `name` attribute). There are additional configuration parameters defined for this plugin. These parameters could be read in the `onConfigure()` method of the plugin class, called before starting the plugin.

.Java plugin example
[source,java]
----
public class EchoPlugin extends JPlugin { // <1>

    private static final Logger logger = LoggerFactory.getLogger(EchoPlugin.class);

    private String echo = "noecho";

    private int count = 1;

    public EchoPlugin() {
    }

    @Override
    public void onConfigure(IConfiguration configuration) {  // <2>
        echo = configuration.getString("echo", echo);
        count = configuration.getInteger("count", count);
    }

    @Override
    public void onInit() {  // <3>
        logger.debug("Initializing {}", getName());
    }

    @Override
    public void onStartup() { // <4>
        logger.debug("Starting up {}", getName());
    }

    public String getEcho() {
        return echo;
    }

    public void setEcho(String echo) {
        this.echo = echo;
    }

    public int getCount() {
        return count;
    }

    public String getEchoConfig() {
        return echo + " x " + count;
    }

    public void sendEchoEvent() {
        getSponge().event("echoEvent").set("echo", getEcho()).send();
    }
}
----
<1> The definition of the plugin class.
<2> The plugin configuration callback method.
<3> The plugin initialization callback method.
<4> The plugin startup callback method.

=== Using plugins

.Using plugin in a script knowledge base
[source,python]
----
class PluginTrigger(Trigger):
    def onConfigure(self):
        self.withEvent("e1")
    def onRun(self, event):
        self.logger.debug("Echo from the plugin: {}", echoPlugin.echo) # <1>
----
<1> Obtaining `echo` bean property from the plugin that is an instance of the class `EchoPlugin`.

An access to the plugin could be achieved in two ways:

* directly using the name `echoPlugin` as any other scripting language variable (this is the preferred way),
* by using the `sponge` API, e.g. `plugin = sponge.getPlugin("echoPlugin")`.

NOTE: A plugin is not accessible in a main body of a script knowledge base because it still won't be initialized when knowledge bases are being loaded. It should be referenced in processors or callback functions.

Because `echoPlugin` implements the method `getEcho()`, you may invoke it in two ways:

* `sponge.getPlugin("echoPlugin").echo`
* `echoPlugin.echo`

[discrete]
=== Example in a script language

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="https://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://sponge.openksavi.org https://sponge.openksavi.org/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase">
            <file>plugins_kb.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="scriptPlugin" class="ScriptPlugin" knowledgeBaseName="sampleKnowledgeBase">
            <configuration>
                <storedValue>Value A</storedValue>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

.Scripting language plugin example
[source,python]
----
class ScriptPlugin(Plugin):
    def onConfigure(self, configuration):
        self.storedValue = configuration.getString("storedValue", "default")
    def onInit(self):
        self.logger.debug("Initializing {}", self.name)
    def onStartup(self):
        self.logger.debug("Starting up {}", self.name)
    def getStoredValue(self):
        return self.storedValue
    def setStoredValue(self, value):
        self.storedValue = value
----

=== Plugin life cycle
{sponge} loads plugins when starting the system according to the steps:

. Creates the plugin class instance. The class must have a no-parameter constructor.
. Configures the plugin by invoking the method `onConfigure()`.
. Initializes the plugin by invoking the method `onInit()`.
. Invokes the callback method `onStartup()` when starting the engine.
. After starting all plugins the methods `onStartup()` defined in all knowledge bases are invoked.
. In case of reloading a knowledge base, the method `onBeforeReload()` of each plugin is invoked before the method `onBeforeReload()` of knowledge bases. Invoking the methods `onAfterReload()` goes in reverse (first the methods `onAfterReload()` of all knowledge bases and then the methods defined in plugins).
. Before {sponge} shuts down, methods `onShutdown()` of all knowledge bases are invoked and then the method `onShutdown()` is invoked for each plugin.

== Exception handling
{sponge} introduces its own runtime exception defined as a Java class `SpongeException`. Exception handling in custom Java components (for example plugins) should follow standard Java conventions. Exception handling in scripting knowledge bases should follow standard conventions for the corresponding scripting language.

== Embedding {sponge} in custom applications
{sponge} may be embedded in a custom Java application using a Maven dependency and the <<engine-builder-api,Engine Builder API>>.

=== Maven dependency
If you want to use {sponge} with, for example, Python scripting knowledge bases, add this dependency to your `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

There is also a Bill Of Materials style maven artifact for {sponge}. Example usage in your `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.openksavi.sponge</groupId>
            <artifactId>sponge-bom</artifactId>
            <version>{projectVersion}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----

In that case you may omit the versions of the dependencies.

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
</dependency>
----

include::includes/user-guide-integration.adoc[leveloffset=+1]

== Best practices
When developing an application using {sponge} you have to be aware of the fact that knowledge bases could be created in two categories of programming languages:

* Java,
* supported scripting languages (e.g. Python, Ruby, Groovy, JavaScript).

Each of these two categories has its pros and cons which makes it better for a certain use. For example scripting languages work well when flexible modification of source code is required.

Libraries written in Java or supported scripting languages may be used, however make sure that they are compatible with the implementations of these languages.

The following chapters describe the best practices for typical use cases.

=== Events
{sponge} is used for developing applications based on event processing. That is why you should start with defining event types. Events should contain enough information (in the form of attributes) so that event processors could provide demanded logic. Moreover, if necessary, you should consider using event chaining, i.e. sending events of a more abstract level based on correlations of low level events.

=== Plugins
If there is a need for creating an interface to an external system, the best way is to use existing or create a new plugin. Once written plugin could be used in other {sponge} based applications.

*In most cases a CamelPlugin, by providing access to all Camel components, should be sufficient when integrating with various systems.*

If there is a need for creating a custom plugin, in most use cases we suggest creating it in Java rather than in a scripting language.

=== Processors
When defining a processor that is not a singleton, its class implementation should provide lightweight creating of new instances.

=== Filters
Filters are especially important when an application cooperates with an external system. If such system sends events, it is a good practice to check if an event contains all expected information and if event attribute values are valid. This type of selection could be done in filters. Filters may also prevent from idly processing events that should be ignored by the application logic at an early phase as they can have an impact on the whole performance.

=== Triggers
Triggers should be implemented in a way to support concurrent processing of many events by different threads. You should avoid class level (static) variables and restrict, if possible, to data transfered in events.

=== Rules
Rules should be used when triggers functionality is not sufficient.

=== Correlators
Correlators should be used when filters, triggers and rules functionality is not sufficient for the problem you try to solve.

=== Actions
Actions should be created only when there is a need to provide some functionality that is to be used in many knowledge bases that are written in different scripting languages and only when you don't want to write it in Java.


== Scripting languages

[[supported-script-languages]]
=== Supported scripting languages
.Supported knowledge base scripting languages
[width=50%]
|===
|Language |Implementation

|Python
|Jython

|Ruby
|JRuby

|Groovy
|Groovy

|JavaScript
|Nashorn
|===

=== Python

==== Limitations
Note that Jython 2.7.1 has a few bugs that could in some cases impact the stability of the system, e.g.: http://bugs.jython.org/issue2487.

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Ruby

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jruby</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Groovy

==== Limitations
In Groovy you cannot define a class or a function twice in the same file. If you want to prepare a processor to reload, you have to put it in a separate file and use `sponge.reloadClass()` method. That separate file could be modified and reloaded.

.Example
[source,groovy]
----
void onLoad() {
    sponge.reloadClass(TriggerA)
    sponge.enable(TriggerA)

    sponge.reloadClass(ActionA)
    sponge.enable(ActionA)
    sponge.call("ActionA")
}
----

For every knowledge base file there is a new Groovy `Script` instance created. For example when reloading, a new Groovy `Script` instance is created for each knowledge base file and they are placed in a list (in a reverse order) to be used by the {sponge} Groovy interpreter internally.

It seems that a Groovy-based knowledge base must have at east one function (may be empty). Otherwise you may get a Groovy exception.

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-groovy</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== JavaScript
JavaScript interpreter supports https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/shell.html[shell scripting extensions in Nashorn] to provide simpler shell integration.

NOTE: Support for JavaScript in {sponge} is deprecated because Nashorn engine is planned to be removed from future JDK releases.

==== Limitations

===== Custom class attributes and methods
There is a limitation for using custom class attributes and methods in processors written in JavaScript implementation Nashorn. In that case you should set a class field `target` in the `onInit()` method as in the following example. All class fields and methods that are new (i.e. not inherited from the base classes) *must be defined in `target`*.

.JavaScript target
[source,javascript]
----
var HeartbeatFilter = Java.extend(Filter, {
    onConfigure: function(self) {
        self.withEvent("heartbeat");
    },
    onInit: function(self) {
        self.target = new function() { // <1>
            this.heartbeatCounter = 0;
        }
    },
    onAccept: function(self, event) {
        self.target.heartbeatCounter++; // <2>
        if (self.target.heartbeatCounter > 2) {
            sponge.removeEvent(hearbeatEventEntry);
            return false;
        } else {
            return true;
        }
    }
});
----
<1> Setting `target` that defines an attribute `heartbeatCounter`.
<2> Using `target` for accessing attribute `heartbeatCounter`.

===== Abstract processors
The support for abstract processors is not implemented for processors written in JavaScript.

===== Dynamic `onCall` callback methods in actions
Dynamic `onCall` callback methods are not supported. Every JavaScript action has to implement the abstract `Object onCall(Object self, Object[] args)` method. Arguments are passed to an action only as an array.

.JavaScript onCall method
[source,javascript]
----
var EmphasizeAction = Java.extend(Action, {
    onCall: function(self, args) {
        self.logger.debug("Action {} called", self.meta.name);
        if (args.length > 0) {
            return "*** " + args[0] + " ***";
        } else {
            return args;
        }
    }
});
----

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-nashorn</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Logging
{sponge} uses https://www.slf4j.org[SLF4J] facade for logging.

Examples and {sponge} standalone command-line application use https://logback.qos.ch[Logback] as a logging implementation.

Java-based processors and plugins may use:

* {sponge} logging, by using the `getLogger()` method, e.g. `getLogger().info("logging")`, or
* own loggers defined in their classes, according to the standard conventions, e.g.
+
[source,java]
----
private static final Logger logger = LoggerFactory.getLogger(ConnectionPlugin.class);
...
    logger.info("logging");
}
----

TIP: You may see ignored events (i.e. events that go to the Output Event Queue) in the logs by setting the `sponge.event.ignored` logger to `INFO`.

include::includes/user-guide-examples.adoc[leveloffset=+1]

== Maven artifacts
The `groupId` of {sponge} Maven artifacts is `org.openksavi.sponge`.

.{sponge} Maven artifacts
[cols="2,1,5"]
|===
|ArtifactId |Central Maven Repository |Description

|`sponge-parent`
|Yes
|The parent project.

|`sponge-bom`
|Yes
|The Bill Of Materials style pom.xml.

|`sponge-api`
|Yes
|The {sponge} API.

|`sponge-core`
|Yes
|The {sponge} core implementation. This artifact includes a shaded Guava library.

|`sponge-jython`
|Yes
|The support for Python-based scripting knowledge bases using Jython.

|`sponge-jython-shaded`
|Yes
|The support for Python-based scripting knowledge bases using Jython. It contains several shaded dependencies. It is an experimental artifact in case of dependency conflicts in an embedded {sponge}.

|`sponge-jruby`
|Yes
|The support for Ruby-based scripting knowledge bases using JRuby.

|`sponge-groovy`
|Yes
|The support for Groovy-based scripting knowledge bases.

|`sponge-nashorn`
|Yes
|The support for JavaScript-based scripting knowledge bases using Nashorn.

|`sponge-kotlin`
|Yes
|The support for Kotlin-based non scripting knowledge bases.

|`sponge-signal`
|Yes
|The wrappers for Operating System signals.

|`sponge-camel`
|Yes
|The Apache Camel integration.

|`sponge-spring`
|Yes
|The Spring framework integration.

|`sponge-py4j`
|Yes
|The CPython integration that uses Py4J.

|`sponge-midi`
|Yes
|The MIDI integration.

|`sponge-rpi-pi4j`
|Yes
|The Pi4J (for Raspberry Pi) library integration.

|`sponge-reactivex`
|Yes
|The ReactiveX integration.

|`sponge-features`
|Yes
|The predefined action and type features.

|`sponge-rest-api-client`
|Yes
|The Sponge REST API client.

|`sponge-rest-api-server`
|Yes
|The Sponge REST API server.

|`sponge-grpc-api-client`
|Yes
|The Sponge gRPC API client.

|`sponge-grpc-api-server`
|Yes
|The Sponge gRPC API server.

|`sponge-remote-api-server`
|Yes
|The Sponge Remote API server (has dependencies on the REST and the gRPC API servers).

|`sponge-tensorflow`
|Yes
|The TensorFlow integration.

|`sponge-standalone`
|Yes
|The base classes for the standalone command-line application.

|`sponge-logging`
|Yes
|The {sponge} logging used by the standalone application.

|`sponge-examples-base`
|Yes
|Base classes used in examples.

|`sponge-test`
|Yes
|The {sponge} test support.

|`sponge-standalone-app`
|No
|The standalone command-line application.

|`sponge-standalone-extensions`
|No
|Dependencies for external libraries used by the standalone command-line application.

|`sponge-rpi-grovepi`
|No
|The GrovePi (for Raspberry Pi) library integration.

|`sponge-examples-projects`
|No
|Complete example projects.

|`sponge-distribution`
|No
|Contains documentation, release configuration, project pages etc.

|`sponge-integration-tests`
|No
|{sponge} integration tests.
|===

include::includes/user-guide-standalone.adoc[leveloffset=+1]

include::includes/user-guide-third-party-software.adoc[leveloffset=+1]
