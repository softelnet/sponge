= User Guide
:page-permalink: /user-guide/
:toc:
:pySourcesUrl: {sourcesUrl}/sponge-jython/examples/script/py/
:rbSourcesUrl: {sourcesUrl}/sponge-jruby/examples/script/rb/
:groovySourcesUrl: {sourcesUrl}/sponge-groovy/examples/script/groovy/
:jsSourcesUrl: {sourcesUrl}/sponge-nashorn/examples/script/js/
:coreSourcesUrl: {sourcesUrl}/sponge-integration-tests/examples/core/
:springSourcesUrl: {sourcesUrl}/sponge-spring/examples/spring/
:camelSourcesUrl: {sourcesUrl}/sponge-camel/examples/camel/
:py4jSourcesUrl: {sourcesUrl}/sponge-py4j/examples/py4j/
:midiSourcesUrl: {sourcesUrl}/sponge-midi/examples/midi/
:tensorflowSourcesUrl: {sourcesUrl}/sponge-tensorflow/examples/tensorflow/

== Introduction
{sponge} is a polyglot system that allows creating knowledge bases in several scripting languages.

For the purpose of clarity, examples in this chapter are written in Python (http://www.jython.org[Jython]) as one of the supported scripting languages and in Java. All examples written in Python may have equivalent ones written in any of the other <<supported-script-languages,supported script languages>>.


include::includes/user-guide-architecture.adoc[leveloffset=+1]


include::includes/user-guide-configuration.adoc[leveloffset=+1]

== Engine

=== Starting up
To startup the engine you should invoke the `startup()` method. After startup, the engine runs in the background (i.e. using threads other than the current one) until you shutdown it.

.Example of starting up
[source,java]
----
SpongeEngine engine = DefaultSpongeEngine.builder().config("examples/script/py/triggers_hello_world.xml").build();
engine.startup();
----

=== Shutting down
When a {sponge} instance is no longer needed it should be shut down by invoking `shutdown()` or `requestShutdown()` method. It instructs the engine to do some clean up, stop all managed threads, free resources, etc. The `shutdown()` uses the current thread to stop the engine. The `requestShutdown()` uses a new thread to stop the engine, thus allowing to shutdown the engine from the within, e.g. form an event processor.

.Example of shutting down in Java
[source,java]
----
engine.shutdown();
----

.Example of shutting down in a script language
[source,python]
----
class SomeTrigger(Trigger):
    def onConfigure(self):
        self.withEvent("e1")
    def onRun(self, event):
        sponge.requestShutdown()
----

Shutting down doesn't guarantee that all events sent to the engine will be processed. However, all events that have already been read from the Input Event Queue (by the Filter Processing Unit) will be fully processed by the engine, if the processing doesn't exceed shutdown timeouts (specified by the `executorShutdownTimeout` configuration parameter). All newer events remaining in the Input Event Queue will not be processed at all.

include::includes/user-guide-knowledge-bases.adoc[leveloffset=+1]

[[types]]
== Data types

=== Supported data types
Data types are represented by instances of classes. The type classes are located in the `org.openksavi.sponge.type` package. Types are used for example as action arguments and result metadata.

.Basic type properties
[cols="1,3"]
|===
|Property |Description

|`name`
|A type location name. It is required if a type is used to specify an action argument metadata. In that case a type name is a name of an action argument. It is also required if a type is used to specify a record type field. A type location name has to be set in a type constructor.

|`label`
|An optional type location label. For example an action argument label or a record field label.

|`description`
|An optional type location description.

|`annotated`
|A flag that tells if a value of this type is annotated. Defaults to `false`.

|`format`
|An optional format.

|`defaultValue`
|An optional default value. A default value for an annotated type must be wrapped in an `AnnotatedValue(value)`.

|`nullable`
|Tells if a value of this type can be `null`. The default is that a value must not be null, i.e. it is *not nullable*.

|`features` (or `feature`)
|Optional features as a map of names to values (as the `Object` type).

|`optional`
|A flag specifying if a value in a location corresponding to this type is optional. Defaults to `false`. It is used in action arguments.

|`provided`
|The _provided_ type specification as an instance of the `ProvidedMeta` class. Defaults to `null`. A provided value has to be an instance of `ProvidedValue`.
|===

A type properties should be set using the builder-style methods, e.g. `StringType("id").withLabel("Identifier")`.

.Provided type specification properties
[cols="1,3"]
|===
|Property |Description

|`value`
|A flag specifying if this type value is provided.

|`valueSet`
|Metadata specifying if a value set is provided. Defaults to `null`. A value set is a list of allowed values. This list of values may be limited (the default setting) or not limited. A limited set means that the type value can be chosen only from the value set. To configure a not limited value set use `withValueSet(ValueSetMeta().withNotLimited())`.

|`elementValueSet`
|A flag specifying if the list element value set is provided. Applicable only for list types. Defaults to `false`. Along with `ListType.unique` it can represent multichoice.

|`depends`
|A list of type names of name paths that this type depends on.

|`readOnly`
|A flag specifying if this type is read only. Defaults to `false`.

|`overwrite`
|A flag specifying if the provided value of this type should overwrite the value set in a client code. Defaults to `false`. This flag should be handled by a client code.

|`submittable`
|A flag specifying if a value can be submitted (i.e. written ad hoc), for example in an action irrespectively of an action call.

|`lazyUpdate`
|A flag specifying if a provided value should be updated lazily in a client code when a dependency changes. This flag is experimental.

|`current`
|A flag specifying if a current value in a client code should be passed to a server when its new value is to be provided.

|`mode`
|A provided read mode: `explicit` (a value has to specified to be provided in `provideArgs`), `optional` (a value may or may not be specified to be provided in `provideArgs`) or `implicit` (a value shouldn't be specified to be provided in `provideArgs`). Defaults to `explicit`. For example a value can be provided optionally or implicitly when an other value is submitted. To set this property to a value other than a default, use the `withOptionalMode()` or the `withImplicitMode()` method.
|===

See the <<provided_arguments,provided action arguments>> as a use case of provided types.

.Data types
[cols="1,5"]
|===
|Type |Description

|`AnyType`
|An any type. It may be used in situations when type is not important.

|`BinaryType`
|A binary (byte array) type. Provides an optional property `mimeType`.

|`BooleanType`
|A boolean type.

|`DateTimeType`
|A date/time type. This type requires a `DateTimeKind` parameter, which is is an enumeration of `DATE_TIME` (a value of this type in Java has to be an instance of `LocalDateTime`), `DATE_TIME_ZONE` (an instance of `ZonedDateTime`), `DATE` (an instance of `LocalDate`), `TIME` (an instance of `LocalTime`), `INSTANT` (an instance of `Instant`). To ensure interoperability with other systems, defining a type format (especially for `DATE` and `TIME`) is recommended and in some cases required. A type format uses the ICU/JDK date/time pattern specification. The {sponge} REST API uses a type format (if defined) to serialize a value of `DateTimeType` to JSON. The default date/time kind is `DATE_TIME`.

|`DynamicType`
|An dynamic type representing dynamically typed values. A value of this type has to be an instance of `DynamicValue`.

|`IntegerType`
|An integer type (commonly used integer type or long). Provides optional properties `minValue`, `maxValue`, `exclusiveMin` and `exclusiveMax`, e.g.: `IntegerType().withMinValue(1).withMinValue(100)`.

|`ListType`
|A list type. This type requires a `DataType` parameter, which is is a type of list elements. Provides optional property `unique` specifying if the list should contain unique values (defaults to `false`). For example: `ListType().withElement(ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject"))`.

|`MapType`
|A map type. This type requires two `DataType` parameters: a type of keys and a type of values in the map. For example: `MapType().withKey(StringType()).withValue(ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject"))`.

|`NumberType`
|A number type, that include both integer and floating-point numbers. Provides optional properties `minValue`, `maxValue`, `exclusiveMin` and `exclusiveMax`, e.g.: `NumberType()`.

|`ObjectType`
|An object. This type requires a class name (typically a Java class name). For example: `ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject")`. It also supports an array notation: `ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject[]")`.

|`RecordType`
|A record type. This type requires a list of named record field types. A value of this type has to be an instance of Map with elements corresponding to the field names and values. E.g.: `RecordType("book").withFields([StringType("author").withLabel("Author"), StringType("title").withLabel("Title")])`. A record type supports inheritance.

|`StreamType`
|A stream type. Supports only output streams. It can be used only as a result of an action. A value of this type has to be an instance of `OutputStreamValue`.

|`StringType`
|A string type. Provides optional properties `minLength` and `maxLength`, e.g.: `StringType().withMaxLength(10)`.

|`TypeType`
|A type representing a data type. A value of this type has to be an instance of `DataType`.

|`VoidType`
|A void type that may be used to specify that an action returns no result.
|===

.Type examples
[source,python]
----
StringType().withMaxLength(10).withFormat("ipAddress")
StringType("ip").withMaxLength(10).withFormat("ipAddress")
IntegerType().withMinValue(1).withMaxValue(100).withDefaultValue(50)
AnyType().withNullable(True)
ListType(StringType())
ListType(ObjectType().withClassName("java.math.BigDecimal"))
ObjectType().withClassName("java.lang.String[]")
ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject")
ListType(ObjectType().withClassName("org.openksavi.sponge.examples.CustomObject"))
BinaryType().withMimeType("image/png").withFeatures({"width":28, "height":28, "color":"white"})
OutputStreamValue(lambda output: IOUtils.write("Sample text file\n", output, "UTF-8")).withContentType("text/plain; charset=\"UTF-8\"").withHeaders({})
----

=== Registering data types
A data type can be registered in the engine in order to be accessed later by its registered type name.

.Engine facade methods for registered types
[cols="1,3"]
|===
|Method |Description

|`addType(String registeredTypeName, DataTypeSupplier<T> typeSupplier)`
|Registers a data type by providing a type supplier that will create a new instance of the registered type each time, e.g. `sponge.addType("Author", lambda: RecordType([StringType("firstName").withLabel("First name"), StringType("surname").withLabel("Surname")]))`.

|`getType(String registeredTypeName)`
|Returns a new instance of the registered data type.

|`getType(String registeredTypeName, String locationName)`
|Returns a new instance of the registered data type setting the returned type location name as well.

|`Map<String, DataType> getTypes()`
|Returns the unmodifiable map of registered data types.
|===

Data types should be registered in the `onBeforeLoad`, because it is invoked before scanning processors.

.The registered data type example
[source,python]
----
def onBeforeLoad():
    sponge.addType("Author", lambda: RecordType([
                StringType("firstName").withLabel("First name"),
                StringType("surname").withLabel("Surname")
            ]))
    sponge.addType("Book", lambda: RecordType([
                sponge.getType("Author", "author").withLabel("Author"),
                StringType("title").withLabel("Title")
            ]))

class GetBookAuthorSurname(Action):
    def onConfigure(self):
        self.withLabel("Get a book author").withArg(sponge.getType("Book").withName("book")).withResult(sponge.getType("Author"))
    def onCall(self, book):
        return book["author"]["surname"]
----

=== Record type inheritance
A record type supports inheritance by setting its base type. Fields in a base type can't be overwritten in a sub-type. Other record type properties are merged. Properties in a sub-type take precedence if they are not set to default values.

.The record inheritance example
[source,python]
----
def onBeforeLoad():
    sponge.addType("Person", lambda: RecordType().withFields([
        StringType("firstName").withLabel("First name"),
        StringType("surname").withLabel("Surname")
    ]))
    sponge.addType("Citizen", lambda: RecordType().withBaseType(sponge.getType("Person")).withFields([
        StringType("country").withLabel("Country")
    ]))
----

=== Annotated values
Annotated values are wrapped by an instance of the `AnnotatedValue` class. An annotated value allows passing a value label, a value description, features, type label and type description along with the value, e.g. `AnnotatedValue(imageBytes).withValueLabel("Image1").withFeatures({"filename":imageFilename})`, where the first property is the annotated value, the second is the value label and the third is the features map that may be used in a client code.

Annotated values can be used to alter a static, metadata-drived behavior of a client application. For example they are especially useful as provided action argument values that carry additional, dynamic data as features.

.Annotated value properties
[cols="1,3"]
|===
|Property |Description

|`value`
|A value that is annotated.

|`valueLabel`
|An optional value label. It can be used as a string representation of the value in a GUI.

|`valueDescription`
|An optional value description. It can be used as a description of the value in a GUI.

|`features`
|Features as a map of names to values.

|`typeLabel`
|An optional type label. Overwrites the type label in a client code.

|`typeDescription`
|An optional type description. Overwrites the type description in a client code.
|===

If a data type is annotated and has a default value, the default value should be wrapped in an `AnnotatedValue`.

== Features
Features are represented by a map of names to values. They provide additional information to data types and processors. They are flexible in a sense that they are not a part of the static API. The predefined features are listed in the {sourcesUrl}/sponge-features/src/main/java/org/openksavi/sponge/features/Features.java[`Features.java`].

Features can be used in a client code to provide specialized behavior.

== Events
Events are the basic element of processing in {sponge}. They have properties such as id, name and send time. The name of an event is also the type of this event. All events than have the same name belong to the same type. Event names should follow Java naming conventions for variable names. Events may have any number of attributes. These attributes will be available, for example, in event processors.

{sponge} supports only point-in-time events.

=== Properties and methods

.Event properties and methods
[cols="1,4"]
|===
|Property / Method |Description

|`id`
|A property that is a global unique identifier of an event (String). This is a shortcut for `getId()`/`setId(text)` methods.

|`name`
|A read-only property that is the name (type) of an event. This is a shortcut for the `getName()` method. A name of an event shouldn't be changed after the event has been created. A name must not be empty nor contain white spaces or reserved characters (`:`). You should also avoid using names that are regular expressions.

|`time`
|A property that is a send time of an event, i.e. a time of adding an event to the Input Event Queue. The time is represented as `java.time.Instant`. This is a shortcut for `getTime()`/`setTime(instant)` methods.

|`label`
|An optional event label.

|`description`
|An optional event description.

|`set(attributeName, value)`
|A method that allows setting an attribute of an event.

|`Object get(attributeName)`
|A method that returns a value of an attribute or throws `IllegalArgumentException` if it does't exist.

|`Object get(attributeClass, attributeName)`
|A method that returns a value of an attribute (assuming it is an instance of `attributeClass`) or throws `IllegalArgumentException` if it does't exist.

|`Object get(attributeName, defaultValue)`
|A method that returns a value of an attribute or `defaultValue` if it does't exist.

|`boolean has(attributeName)`
|A method that checks if an event has an attribute.

|`all`
|A property that returns a map of all attributes. This is a shortcut for the `getAll()` method.

|`Event clone()`
|A method that clones an event.
|===

Properties `id` and `time` are automatically set when adding an event to the Input Event Queue and there is no need for setting them manually.

=== Typical event processing
In order to process an event there must be an event processor listening to events of that type (the types of events are recognized by their names). So this steps should be taken:

* Creating an event processor.
* Enabling the event processor automatically or manually (by invoking a proper `sponge.enable*()` method).
* Creating a new event instance and sending it to the system (e.g. `sponge.event("alarm").set("location", "Building 1").send()`.
* The event goes directly to the Input Event Queue or is scheduled to be inserted to the Input Event Queue later. Scheduling is performed by the Event Scheduler.
* From this queue the events are taken by the Filter Processing Unit. The list of filters defined for this event type is taken and then each of them is invoked. If all filters accept the event, it will be put to the Main Event Queue in which it will await to be processed by other event processors.
* Then the event is collected by the Main Processing Unit. The list of event processors listening to this type of events is selected and then each of them is given the event to process.
* After processing by the Main Processing Unit the event goes to the Output Event Queue if and only if it hasn't been processed (i.e. listened to) by any of event processors.

=== Event cloning
The event is cloned each time when the periodically generated events are sent to the Input Event Queue.

The standard implementation of events allows choosing the cloning policy `shallow` or `deep`. These policies differ in the way of cloning of events attributes. When using the former, the references to attributes are copied - each event processor works on the same attribute instances. The policy `deep` executes the procedure of deep cloning, so each next generated event will contain individual copies of the attributes.

=== Custom events
The default implementation of an event is the `AttributeMapEvent` class. However, {sponge} allows to use custom event implementations of the `Event` interface.

=== System events
System events are sent automatically by the engine. An event sent in your code shouldn't have the same name as any of the system events. Currently there is only one system event.

.System events
[cols="1,4"]
|===
|Event name |Description

|`startup`
|The `startup` event will be sent as the first event when the engine is starting up.
|===

==== Startup system event
The `startup` system event could be useful to define rules or correlators that detect lack of other events since the startup of the engine.

The following rule detects a situation when there is no `heartbeat` event for `5` seconds since the startup of {sponge}.

.Example of startup system event
[source,python]
----
class DetectLackOfHearbeat(Rule):
    def onConfigure(self):
        self.withEvents(["startup", "heartbeat :none"]).withDuration(Duration.ofSeconds(5))
    def onRun(self, event):
        print "No heartbeat!"
----

=== Control events
Control events are used by the engine internally. The names of control events have a prefix `$`. You shouldn't give to your events a name that starts with this character.

=== Creating and sending events
*Creating an event means creating an instance of an event class. Sending an event means that the created event will be put into the Input Event Queue, to be processed by filters and then by triggers, rules and correlators.*

Event can be created and sent using the EventDefinition fluent API (e.g. `sponge.event("helloEvent").set("say", "Hello World!").send()`). The method `sponge.event` returns `EventDefinition`.

An event may be sent as:

* A single instance – the event will be placed in the Input Event Queue only once.
* Many instances periodically – new instances of an event will be placed in the Input Event Queue periodically, each of them with its own id and send time.

.`EventDefinition` methods
[cols="1,4"]
|===
|Method |Description

|`EventDefinition set(String name, Object value)`
|Sets the event attribute.

|`EventDefinition modify(EventDefinitionModifier modifier)`
|Modifies the underlying event.

|`send()`
|Sends an event immediately.

|`sendAfter(delay)`
|Sends an event after a specified time (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]). Note that the order of inserting events to the Input Event Queue may be different than the order of invocations of `sendAfter`, even with the same `delay`. It depends on the internal implementation of the Quartz library.

|`sendAfter(delay, interval)`
|Periodically sends events after a specified time (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]) every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`sendAt(at)`
|Sends an event at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970 or as an {javaSeJavaDocUrl}/java/time/Instant.html[`Instant`]).

|`sendAt(at, interval)`
|Periodically sends events starting at the specified time (given in milliseconds as the number of milliseconds since 01/01/1970 or as an {javaSeJavaDocUrl}/java/time/Instant.html[`Instant`]) every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`sendAt(crontabSpec)`
|Sends events at time specified by Cron compatible time entry.

|`sendEvery(interval)`
|Periodically sends events every `interval` (given in milliseconds or as a {javaSeJavaDocUrl}/java/time/Duration.html[`Duration`]).

|`Event make()`
|Only returns the newly created event without sending.
|===

=== Examples of sending events
Sample sending of events from the level of a knowledge base:

[source,python]
----
sponge.event("e1").sendAfter(Duration.ofSeconds(1))
----
Sends the event named `"e1"` after `1` second from now.

[source,python]
----
sponge.event("e2").sendAfter(2000, 1000)
----
Sends the event named `"e2"` after `2` seconds from now. New events will be periodically generated and sent every second.

[source,python]
----
sponge.event("e2").set("color", "red").set("severity", 5).send()
----
Sends an event with attributes `"color"` and `"severity"` immediately.

[source,python]
----
sponge.event("alarm").sendAt("0-59 * * * * ?")
----
Sends an event at the time specified by Cron notation.

=== Registered event types
Event type may be registered in the engine. The registered event type is a `RecordType` that describes event attributes. The name of an event instance is also a registration name of a registered event type. Event types are are not verified by the engine but could be interpreted by a client code or {sponge} plugins. For example they could be useful in a generic GUI that sends or subscribes to events.

.Example of registering event types
[source,python]
----
def onBeforeLoad():
    sponge.addEventType("notification", RecordType().withFields([
        StringType("source").withLabel("Source"),
        IntegerType("severity").withLabel("Severity").withNullable()
    ]).withLabel("Notification"))

def onStartup():
    sponge.event("notification").set({"source":"Sponge", "severity":10}).label("The notification").description("The new event notification").send()
----

=== Event priorities
A priority may be assigned only to control events, that are used internally by the engine. For standard events the priority always equals to `0` and cannot be modified.

A priority defines a level of the importance of an event. Events are added to and taken from queues with respect to their priorities. Priority is a positive or negative integer and the higher the number is, the higher is the priority of an event and the event will be processed before the others.

== Processors
Processors are the basic objects that you define in {sponge} to implement your knowledge base behavior.

Types of processors:

* *Actions* - processors that provide functionality similar to functions. They don't listen to events.
* *Event processors* - processors that perform specified operations using events they listen to.
** *Filters* - event processors used for allowing only certain events to be later processed by other event processors.
** *Triggers* -  event processors that execute a specified code when an event happens.
** *Event set processors* - event processors that process sets of events.
*** *Rules* - event set processors that detect sequences of events.
*** *Correlators* - event set processors that detect any set of events and could be also used for implementing any complex event processing that isn't provided by filters, triggers or rules.

A processors can be defined by a class or by a processor builder.

=== Processors defined by classes

==== Definition
In order to define your processor in a script knowledge base, you have to create a class extending the base class pointed by a specific alias (e.g. `Filter` for filters). In order to define your processor in a Java knowledge base, you have to create a class extending a specific class (e.g. `JFilter` for filters).

A name of a processor is a name of a class defining this processor.

==== Enabling
The operation of registering a processor in the engine is called enabling. Registered processors are available to the engine to perform specific tasks. For example, after enabling an event processor starts listening to events it is interested in.

Processors could be enabled:

* by auto-enable (this is the default setting for script-based processors),
* manually.

===== Auto-enable
{sponge} automatically enables all processors (i.e. actions, filters, triggers, rules and correlators) defined as classes in a script knowledge base. This is done just before invoking the `onLoad` callback function in the knowledge base. Processor classes whose names start with the `Abstract` prefix are considered abstract and will not be automatically enabled.

Enabling Java-based processors has to be done manually.

For non script knowledge bases (Java or Kotlin based) the auto-enable feature will scan only for processor classes nested in a corresponding knowledge base class. Other processors have to be enabled manually.

.Example of processor inheritance and auto-enable
[source,python]
----
# This abstract action will not be automatically enabled.
class AbstractCalculateAction(Action):
    def calculateResult(self):
        return 1

# This action will be automatically enabled.
class CalculateAction(AbstractCalculateAction):
    def onCall(self):
        return self.calculateResult() * 2
----

You may turn off auto-enable by setting the `autoEnable` engine configuration parameter to `false` (for example in the Sponge XML configuration file). In that case you have to enable processors manually.

===== Manual enabling
In most cases enabling processors manually should be done in the `onLoad` callback function.

To manually enable any script-based processors in a script knowledge base you may use: `sponge.enable()` to enable one processor and `sponge.enableAll()` to enable many processors.

.Example of enabling a script-based processor
[source,python]
----
def onLoad:
    sponge.enable(TriggerA)
----

.Example of enabling script-based processors
[source,python]
----
def onLoad:
    sponge.enableAll(Trigger1, Trigger3)
----

To manually enable any Java-based processors in a script knowledge base you may use `sponge.enableJava()`, `sponge.enableJavaAll()` or `sponge.enableJavaByScan()`. The default name of a Java-based processor is its full Java class name.

The `enableJavaByScan` method enables Java-based processors by scanning a given packages in search of all non abstract processor classes. The scanning is performed by the https://github.com/ronmamo/reflections[Reflections] library. The method parameters are compatible with the http://ronmamo.github.io/reflections/index.html?org/reflections/Reflections.html[`Reflections(Object...)`] constructor.

.Example of enabling one Java-based processor
[source,python]
----
def onLoad():
    sponge.enableJava(SameSourceJavaRule)
----

.Example of enabling many Java-based processors
[source,python]
----
def onLoad():
    sponge.enableJavaAll(SameSourceJavaRule, SameSourceJavaRule2, SameSourceJavaRule3)
----

.Example of enabling Java-based processors by scanning Java packages
[source,python]
----
def onLoad():
    sponge.enableJavaByScan("org.openksavi.sponge.integration.tests.core.scanning")
----

==== Disabling
Processors can be disabled only manually. To disable any script-based processors in a script knowledge base you may use `sponge.disable()` to disable one processor and `sponge.disableAll()` to disable many processors.

.Example of disabling a script-based processor
[source,python]
----
def onLoad:
    sponge.disable(EchoAction)
----

To disable any Java-based processors in a script knowledge base you may use `sponge.disableJava()`, `sponge.disableJavaAll()` or `sponge.disableJavaByScan()`.

.Example of disabling a Java-based processor
[source,python]
----
def onLoad():
    sponge.disableJava(SameSourceJavaRule)
----

Any processor can be disabled by its name.

.Example of disabling a processor by its name
[source,python]
----
sponge.disable("EchoAction")
----

=== Processors defined by processor builders
In order to define your processor by a processor builder you have to configure it using a builder fluter API and manually enable in the engine. A name of a processor is a text passed to a builder constructor.

.Definition and enabling an action using a builder
[source,python]
----
def onLoad:
    sponge.enable(ActionBuilder("HelloWorldAction").withOnCall(lambda action, name: "Hello World! Hello {}!".format(name)))
----

A processor defined by a processor builder can be disabled by its name.

=== Properties and methods

[[processor-methods]]
.Processor properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|*`onConfigure()`*
|The configuration callback method that will be invoked when a processor is being enabled. This method is mandatory for processors defined as classes.

|`onInit()`
|The initialization callback method that will be invoked after `onConfigure()`, each time a new working instance of the processor is created.

|`withName(String name)`
|Sets a processor name. The name can be read using `self.meta.name`. Because names of processors are created automatically, this method shouldn't be invoked directly.

|`withLabel(String label)`
|Sets a processor label. The label can be read using `self.meta.label`. A label is not used internally but could be useful in a client code.

|`withDescription(String description)`
|Sets a processor description. The description can be read using `self.meta.description`. A description is not used internally but could be useful in a client code.

|`withVersion(Integer version)`
|Sets a processor version. The version can be read using `self.meta.version`. A version is not used internally by the engine. However it is used to enforce version checking when calling actions via the REST API.

|`withFeatures(Map<String, Object> features)`
|Adds processor features. The features can be read using `self.meta.features`. The processor features is simply a map of String to Object associated with a processor definition (not instance). It could be used to provide a custom behavior in a client code.

|`withFeature(String name, Object value)`
|Adds a single processor feature.

|`withCategory(String category)`
|Sets a processor category. The category can be read using `self.meta.category`. A category is not used internally but could be useful in a client code.

|`meta`
|The read-only property that provides a processor metadata.

|`logger`
|The read-only property that provides a processor logger. This is a shortcut for `getLogger()` method. A processor logger name has the following format: `sponge.kb.<language>.<knowledgeBaseName>.<processorName>`, e.g. `sponge.kb.python.kb1.EchoAction` for a python-based processor, `sponge.kb.python.kb1.org.openksavi.sponge.examples.PowerEchoAction` for a Java-based processor enabled in a Python-based knowledge base.

|`adapter`
|The read-only property that provides a processor adapter. This is a shortcut for `getAdapter()` method. A processor adapter is an internal object, associated with the processor, that is used by the engine. There should be no need to use this property in the client code.
|===

Processors provide builder-style, fluent methods to set metadata properties, e.g. `self.withLabel("Label").withDescription("Description")`. In many scripting languages properties can be accessed using a dot notation rather than a direct method call. For example a processor metadata may be read using `self.meta` or `self.getMeta()`.

.Processor builder specific properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`withOnInit(ProcessorOnInitCallback onInitCallback)`
|Configures the `onInit()` callback function that accepts one argument - the processor instance, e.g. `withOnInit(lambda action: sponge.setVariable("v1", True))`.
|===

include::includes/user-guide-actions.adoc[leveloffset=+1]

include::includes/user-guide-event-processors.adoc[leveloffset=+1]

== Plugins
Plugins are used for expanding {sponge} with new functionalities and use them in knowledge bases. Typically they provide access to and from external systems.

The alias for the base class for script-based plugins is `Plugin`. The base class for Java-based plugins is `JPlugin`.

Each of these base classes extends the `BasePlugin` class that provides empty implementations of callback methods. If the created plugin requires own configuration parameters (e.g. in the XML configuration file) the `onConfigure` method should be implemented.

Each plugin is also an engine module and that means that in inherits from the `BaseEngineModule` class.

Plugins could be written in Java or in a supported scripting language as a part of a scripting knowledge base. However plugins written in a scripting language must be used only in the same scripting knowledge base they were defined in. That is because there are limitations of scripting languages interoperation. Only plugins written in Java could be used in any scripting knowledge base.

=== Properties and methods

.Plugin properties and methods
[cols="1,5"]
|===
|Property / Method |Description

|`name`
|The property that is a name of a plugin. This is a shortcut for `getName()`/`setName(text)` methods. Because of names of plugins are created automatically, the setter shouldn't be used in a client code.

|`onConfigure(Configuration configuration)`
|The configuration callback method that will be invoked after a plugin has been loaded. This method allows reading an XML configuration for the plugin.

|`onInit()`
|The initialization callback method that will be invoked after a configuration of a plugin.

|`onStartup()`
|The callback method that will be invoked once after the startup of the engine.

|`onShutdown()`
|The callback method that will be invoked once before the shutdown of the engine.

|`onBeforeReload()`
|The callback method that will be invoked before every reloading of a knowledge base.

|`onAfterReload()`
|The callback method that will be invoked after every reloading of a knowledge base.

|`logger`
|The read-only property that provides a plugin logger. This is a shortcut for `getLogger()` method. A plugin logger name has the following format: `sponge.kb.plugin.<pluginName>`. Example logger name: `sponge.kb.plugin.scriptPlugin`.
|===

[discrete]
=== Example in Java

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="https://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://sponge.openksavi.org https://sponge.openksavi.org/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase">
            <file>plugins_java.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="echoPlugin" class="org.openksavi.sponge.examples.EchoPlugin">
            <configuration>
                <echo>Echo test!</echo>
                <count>2</count>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

This plugin definition section contains:

* The unique name of the plugin. This name may be used in knowledge bases as a variable referencing this plugin instance.
* The class name of the plugin. It could be a Java class name or a scripting language class name. If the plugin is defined in a scripting knowledge base than you must specify that knowledge base name as an XML tag `<knowledgeBaseName>`.
* Custom configuration for a plugin. That section could be any XML that is understood by this plugin.

The above configuration defines a plugin implemented by `org.openksavi.sponge.examples.EchoPlugin` class. This plugin may be used in the knowledge base as a global variable named `echoPlugin` (according to the `name` attribute). There are additional configuration parameters defined for this plugin. These parameters could be read in the `onConfigure()` method of the plugin class, called before starting the plugin.

.Java plugin example
[source,java]
----
public class EchoPlugin extends JPlugin { // <1>

    private static final Logger logger = LoggerFactory.getLogger(EchoPlugin.class);

    private String echo = "noecho";

    private int count = 1;

    public EchoPlugin() {
    }

    @Override
    public void onConfigure(IConfiguration configuration) {  // <2>
        echo = configuration.getString("echo", echo);
        count = configuration.getInteger("count", count);
    }

    @Override
    public void onInit() {  // <3>
        logger.debug("Initializing {}", getName());
    }

    @Override
    public void onStartup() { // <4>
        logger.debug("Starting up {}", getName());
    }

    public String getEcho() {
        return echo;
    }

    public void setEcho(String echo) {
        this.echo = echo;
    }

    public int getCount() {
        return count;
    }

    public String getEchoConfig() {
        return echo + " x " + count;
    }

    public void sendEchoEvent() {
        getSponge().event("echoEvent").set("echo", getEcho()).send();
    }
}
----
<1> The definition of the plugin class.
<2> The plugin configuration callback method.
<3> The plugin initialization callback method.
<4> The plugin startup callback method.

=== Using plugins

.Using plugin in a script knowledge base
[source,python]
----
class PluginTrigger(Trigger):
    def onConfigure(self):
        self.withEvent("e1")
    def onRun(self, event):
        self.logger.debug("Echo from the plugin: {}", echoPlugin.echo) # <1>
----
<1> Obtaining `echo` bean property from the plugin that is an instance of the class `EchoPlugin`.

An access to the plugin could be achieved in two ways:

* directly using the name `echoPlugin` as any other scripting language variable (this is the preferred way),
* by using the `sponge` API, e.g. `plugin = sponge.getPlugin("echoPlugin")`.

NOTE: A plugin is not accessible in a main body of a script knowledge base because it still won't be initialized when knowledge bases are being loaded. It should be referenced in processors or callback functions.

Because `echoPlugin` implements the method `getEcho()`, you may invoke it in two ways:

* `sponge.getPlugin("echoPlugin").echo`
* `echoPlugin.echo`

[discrete]
=== Example in a script language

.Definition of the plugin in the XML configuration file
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<sponge xmlns="https://sponge.openksavi.org" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://sponge.openksavi.org https://sponge.openksavi.org/schema/config.xsd">
    <knowledgeBases>
        <knowledgeBase name="sampleKnowledgeBase">
            <file>plugins_kb.py</file>
        </knowledgeBase>
    </knowledgeBases>
    <plugins>
        <plugin name="scriptPlugin" class="ScriptPlugin" knowledgeBaseName="sampleKnowledgeBase">
            <configuration>
                <storedValue>Value A</storedValue>
            </configuration>
        </plugin>
    </plugins>
</sponge>
----

.Scripting language plugin example
[source,python]
----
class ScriptPlugin(Plugin):
    def onConfigure(self, configuration):
        self.storedValue = configuration.getString("storedValue", "default")
    def onInit(self):
        self.logger.debug("Initializing {}", self.name)
    def onStartup(self):
        self.logger.debug("Starting up {}", self.name)
    def getStoredValue(self):
        return self.storedValue
    def setStoredValue(self, value):
        self.storedValue = value
----

=== Plugin life cycle
{sponge} loads plugins when starting the system according to the steps:

. Creates the plugin class instance. The class must have a no-parameter constructor.
. Configures the plugin by invoking the method `onConfigure()`.
. Initializes the plugin by invoking the method `onInit()`.
. Invokes the callback method `onStartup()` when starting the engine.
. After starting all plugins the methods `onStartup()` defined in all knowledge bases are invoked.
. In case of reloading a knowledge base, the method `onBeforeReload()` of each plugin is invoked before the method `onBeforeReload()` of knowledge bases. Invoking the methods `onAfterReload()` goes in reverse (first the methods `onAfterReload()` of all knowledge bases and then the methods defined in plugins).
. Before {sponge} shuts down, methods `onShutdown()` of all knowledge bases are invoked and then the method `onShutdown()` is invoked for each plugin.

== Exception handling
{sponge} introduces its own runtime exception defined as a Java class `SpongeException`. Exception handling in custom Java components (for example plugins) should follow standard Java conventions. Exception handling in scripting knowledge bases should follow standard conventions for the corresponding scripting language.

== Embedding {sponge} in custom applications
{sponge} may be embedded in a custom Java application using a Maven dependency and the <<engine-builder-api,Engine Builder API>>.

=== Maven dependency
If you want to use {sponge} with, for example, Python scripting knowledge bases, add this dependency to your `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

There is also a Bill Of Materials style maven artifact for {sponge}. Example usage in your `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.openksavi.sponge</groupId>
            <artifactId>sponge-bom</artifactId>
            <version>{projectVersion}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----

In that case you may omit the versions of the dependencies.

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
</dependency>
----

include::includes/user-guide-integration.adoc[leveloffset=+1]

== Best practices
When developing an application using {sponge} you have to be aware of the fact that knowledge bases could be created in two categories of programming languages:

* Java,
* supported scripting languages (e.g. Python, Ruby, Groovy, JavaScript).

Each of these two categories has its pros and cons which makes it better for a certain use. For example scripting languages work well when flexible modification of source code is required.

Libraries written in Java or supported scripting languages may be used, however make sure that they are compatible with the implementations of these languages.

The following chapters describe the best practices for typical use cases.

=== Events
{sponge} is used for developing applications based on event processing. That is why you should start with defining event types. Events should contain enough information (in the form of attributes) so that event processors could provide demanded logic. Moreover, if necessary, you should consider using event chaining, i.e. sending events of a more abstract level based on correlations of low level events.

=== Plugins
If there is a need for creating an interface to an external system, the best way is to use existing or create a new plugin. Once written plugin could be used in other {sponge} based applications.

*In most cases a CamelPlugin, by providing access to all Camel components, should be sufficient when integrating with various systems.*

If there is a need for creating a custom plugin, in most use cases we suggest creating it in Java rather than in a scripting language.

=== Processors
When defining a processor that is not a singleton, its class implementation should provide lightweight creating of new instances.

=== Filters
Filters are especially important when an application cooperates with an external system. If such system sends events, it is a good practice to check if an event contains all expected information and if event attribute values are valid. This type of selection could be done in filters. Filters may also prevent from idly processing events that should be ignored by the application logic at an early phase as they can have an impact on the whole performance.

=== Triggers
Triggers should be implemented in a way to support concurrent processing of many events by different threads. You should avoid class level (static) variables and restrict, if possible, to data transfered in events.

=== Rules
Rules should be used when triggers functionality is not sufficient.

=== Correlators
Correlators should be used when filters, triggers and rules functionality is not sufficient for the problem you try to solve.

=== Actions
Actions should be created only when there is a need to provide some functionality that is to be used in many knowledge bases that are written in different scripting languages and only when you don't want to write it in Java.


== Scripting languages

[[supported-script-languages]]
=== Supported scripting languages
.Supported knowledge base scripting languages
[width=50%]
|===
|Language |Implementation

|Python
|Jython

|Ruby
|JRuby

|Groovy
|Groovy

|JavaScript
|Nashorn
|===

=== Python

==== Limitations
Note that Jython 2.7.1 has a few bugs that could in some cases impact the stability of the system, e.g.: http://bugs.jython.org/issue2487.

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jython</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

The dependency for Jython used in {sponge} is https://github.com/scijava/jython-shaded[Jython shaded].

=== Ruby

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-jruby</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== Groovy

==== Limitations
In Groovy you cannot define a class or a function twice in the same file. If you want to prepare a processor to reload, you have to put it in a separate file and use `sponge.reloadClass()` method. That separate file could be modified and reloaded.

.Example
[source,groovy]
----
void onLoad() {
    sponge.reloadClass(TriggerA)
    sponge.enable(TriggerA)

    sponge.reloadClass(ActionA)
    sponge.enable(ActionA)
    sponge.call("ActionA")
}
----

For every knowledge base file there is a new Groovy `Script` instance created. For example when reloading, a new Groovy `Script` instance is created for each knowledge base file and they are placed in a list (in a reverse order) to be used by the {sponge} Groovy interpreter internally.

It seems that a Groovy-based knowledge base must have at east one function (may be empty). Otherwise you may get a Groovy exception.

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-groovy</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

=== JavaScript
JavaScript interpreter supports https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/shell.html[shell scripting extensions in Nashorn] to provide simpler shell integration.

NOTE: Support for JavaScript in {sponge} is deprecated because Nashorn engine is planned to be removed from future JDK releases.

==== Limitations

===== Custom class attributes and methods
There is a limitation for using custom class attributes and methods in processors written in JavaScript implementation Nashorn. In that case you should set a class field `target` in the `onInit()` method as in the following example. All class fields and methods that are new (i.e. not inherited from the base classes) *must be defined in `target`*.

.JavaScript target
[source,javascript]
----
var HeartbeatFilter = Java.extend(Filter, {
    onConfigure: function(self) {
        self.withEvent("heartbeat");
    },
    onInit: function(self) {
        self.target = new function() { // <1>
            this.heartbeatCounter = 0;
        }
    },
    onAccept: function(self, event) {
        self.target.heartbeatCounter++; // <2>
        if (self.target.heartbeatCounter > 2) {
            sponge.removeEvent(hearbeatEventEntry);
            return false;
        } else {
            return true;
        }
    }
});
----
<1> Setting `target` that defines an attribute `heartbeatCounter`.
<2> Using `target` for accessing attribute `heartbeatCounter`.

===== Abstract processors
The support for abstract processors is not implemented for processors written in JavaScript.

===== Dynamic `onCall` callback methods in actions
Dynamic `onCall` callback methods are not supported. Every JavaScript action has to implement the abstract `Object onCall(Object self, Object[] args)` method. Arguments are passed to an action only as an array.

.JavaScript onCall method
[source,javascript]
----
var EmphasizeAction = Java.extend(Action, {
    onCall: function(self, args) {
        self.logger.debug("Action {} called", self.meta.name);
        if (args.length > 0) {
            return "*** " + args[0] + " ***";
        } else {
            return args;
        }
    }
});
----

[discrete]
==== Maven configuration
Maven users will need to add the following dependency to their `pom.xml`:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.openksavi.sponge</groupId>
    <artifactId>sponge-nashorn</artifactId>
    <version>{projectVersion}</version>
</dependency>
----

== Logging
{sponge} uses https://www.slf4j.org[SLF4J] facade for logging.

Examples and {sponge} standalone command-line application use https://logback.qos.ch[Logback] as a logging implementation.

Java-based processors and plugins may use:

* {sponge} logging, by using the `getLogger()` method, e.g. `getLogger().info("logging")`, or
* own loggers defined in their classes, according to the standard conventions, e.g.
+
[source,java]
----
private static final Logger logger = LoggerFactory.getLogger(ConnectionPlugin.class);
...
    logger.info("logging");
}
----

TIP: You may see ignored events (i.e. events that go to the Output Event Queue) in the logs by setting the `sponge.event.ignored` logger to `INFO`.

== Examples

=== Complete example projects of embedding {sponge}
The complete projects could be used as a point of reference to embed {sponge} in your Java application. They are placed in `sponge-examples-projects`.

==== News project
This project shows how to process news as events. It is placed in `sponge-examples-project-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-news[sources]).

Event flow:

* News are manually generated and sent as {sponge} events named `news` in `onStartup` function of the knowledge base named `newsGenerator`. Each event has custom attributes: `source` and `title`.
* Every event named `news` is filtered to discard news that have empty or short (according to `newsFilterWordThreshold` configuration property) titles. This is done by `NewsFilter` filter.
* Events named `news` are logged by `LogNewsTrigger` trigger.
* When there are no new `news` events (that passed filters) for a specified time, then `alarm` event is sent. This is done by `NoNewNewsAlarmRule` rule.
* `LatestNewsCorrelator` correlator listens to `news` events and stores the latest news in `storagePlugin` plugin in a Python `deque`. The number of latest news is configured as `latestNewsMaxSize` property.
* When `alarm` event happens, this fact is logged by `AlarmTrigger` trigger using `echoPlugin` plugin and `EmphasizeAction` action.


.Main class - NewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/NewsExampleMain.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-news/config/config.xml[]
----

.Python-based knowledge base 'main' file - main_event_processors.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_event_processors.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_functions.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_functions.py[lines=5..-1]
----

.Python-based knowledge base 'main' file - main_plugins.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/main_plugins.py[lines=5..-1]
----

.JavaScript-based knowledge base 'actions' file - actions.js
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/actions.js[actions.js]
----

.Python-based knowledge base that generates sample news - news_generator.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-news/kb/news_generator.py[lines=5..-1]
----

.Java-based plugin class - MultiEchoPlugin
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-news/src/main/java/org/openksavi/sponge/examples/project/news/MultiEchoPlugin.java[lines=17..-1]
----

==== Camel RSS News project
This example is an enhancement over the News project example. It is placed in `sponge-examples-project-camel-rss-news` (see {sourcesUrl}/sponge-examples-projects/sponge-examples-project-camel-rss-news[sources]).

The main change here is that news are acquired as RSS feeds from news services: BBC and CNN. Reading RSS feeds and transformation to {sponge} events is performed in a Camel route. {sponge} acts as a producer in this Camel route. This example shows {sponge} as a consumer in other Camel routes as well.

This example also presents integration with Spring framework. A service provided as a Spring bean is accessed from the script knowledge base.

Knowledge bases `main` and `actions` that existed in the News project example are not changed. This is because the main processing is independent of the input and output interfaces, protocols or data structures. Internal events (in this case `news` events) are normalized.

Event flow:

* RSS feeds are read from external sources, transformed to {sponge} events and sent to the {sponge} engine. This is done in Camel routes.
* The `main` knowledge base related event flow is the same as in the previous example.
* After the time configured as a property `durationOfReadingRss` Camel routes that read RSS feeds from external sources are stopped. It simulates lack of new news. This is done in the `simulator` knowledge base.
* When `alarm` event happens, not only `AlarmTrigger` (as described in the previous example) handles that event, but here also `ForwardAlarmTrigger` trigger, defined in the `consumer` knowledge base. It sends an alarm message to:
** all Camel endpoints that use the Sponge engine as a consumer in their routes,
** to a specific endpoint given as URI.

.Main class - CamelRssNewsExampleMain
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/CamelRssNewsExampleMain.java[lines=17..-1]
----

.Spring Java configuration - SpringConfiguration
[source,java]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/src/main/java/org/openksavi/sponge/examples/project/camelrssnews/SpringConfiguration.java[lines=17..-1]
----

.{sponge} XML configuration file - config.xml
[source,xml]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/config/config.xml[]
----

.Python-based extended configuration - config.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/config.py[lines=5..-1]
----

.Python-based knowledge base that sends messages to Camel as a consumer - consumer.py
[source,python]
----
include::{completeExamplesProject}/sponge-examples-project-camel-rss-news/kb/consumer.py[lines=5..-1]
----

[[rest-api-demo-service]]
==== REST API Demo Service
The {sourcesUrl}/sponge-examples-projects/sponge-examples-project-demo-service[Demo Service] use case shows how to deploy the REST API as a servlet. It uses <<rest-api-server-simple-security-strategy,the simple security strategy>>. There are a few options to run the demo.

[discrete]
===== Using the hosted Demo Service
The Demo Service hosted at `https://spongedemoapi.openksavi.org` provides an anonymous access to the {sponge} demo. It is used by the {sponge} mobile client application as a predefined connection. You can also connect to the service using command line tools.

[source,bash,subs="verbatim,attributes"]
----
curl -H "Content-type:application/json" https://spongedemoapi.openksavi.org/version
----

[discrete]
===== Running in Docker
The Docker image `openksavi/sponge-demo` contains a predefined REST API Demo Service running in Tomcat. I can be used as a {sponge} mobile client application playground in your local environment.

NOTE: The predefined file `password.txt` contains the hashed, insecure password `password` for the user `admin`. You should change it or use this demo only for tests in a secure network.

.Initialization and configuration
[source,bash,subs="verbatim,attributes"]
----
# Run the demo in Docker using the predefined {sponge} configuration.
docker run --name sponge-demo -it --rm -p 8080:8080 -p 8081:8081 openksavi/sponge-demo

# Copy the predefined {sponge} configuration to the host in order to modify knowledge base files.
docker cp sponge-demo:/opt/sponge/ .

# Stop the running container.
docker stop sponge-demo

# Start a new container using a new {sponge} configuration located in the host filesystem.
# The configurtion directory is expected to have the sponge.xml file.
docker run --name sponge-demo -it --rm -p 8080:8080 -p 8081:8081 --mount type=bind,source="$(pwd)/sponge",target=/opt/sponge openksavi/sponge-demo
----

The port `8080` is used by the REST API and the port `8081` is used by the gRPC API.

.Verification
[source,bash,subs="verbatim,attributes"]
----
# Test the service.
curl http://localhost:8080/sponge.json/v1/version

# Invoke shell in the container.
docker exec -it sponge-demo /bin/bash
----

.Development process
[source,bash,subs="verbatim,attributes"]
----
# Modify the {sponge} configuration in the host.
vi sponge_demo.py
# For example add a new action.
class HelloWorld(Action):
    def onConfigure(self):
        self.withLabel("Hello World").withDescription("The action created in a running Docker container.")
        self.withNoArgs().withResult(StringType().withLabel("Greeting"))
        self.withFeature("icon", "human-greeting")
    def onCall(self):
        return "Hello World!"

# Reload the knowledge bases as admin via a commandline tool or the {sponge} mobile client application.
curl -X POST -H "Content-type:application/json" http://localhost:8080/sponge.json/v1/reload -d '{"header":{"username":"admin","password":"password"}}'

# Refresh actions in the {sponge} mobile client application.
# The new action will be visible in the action list.
----

[discrete]
===== Setting up manually and deploying in Tomcat
First, you have to create the web application and {sponge} scripts.
[source,bash,subs="verbatim,attributes"]
----
cd sponge-examples-projects/sponge-examples-project-demo-service
mvn clean install -Pall
----

The resulting archive `target/sponge-demo-api.war` is the web application providing the Demo REST API service. The archive `target/sponge-scripts.zip` contains Sponge script files and the Digits recognition example files (see the TensorFlow integration chapter) that will be accessed by the web application.

Assuming that Tomcat is installed in `/opt/tomcat` and the Sponge script files and the Digits recognition example files are extracted into the `/opt/tomcat/sponge` directory, you should add the following properties to the `catalina.properties` file:
----
sponge.home=/opt/tomcat/sponge
digits.home=/opt/tomcat/sponge/digits
password.file=/opt/tomcat/sponge/password.txt
sponge.grpc.port=8081
----

The sample file `password.txt` contains the hashed, insecure password `password` for the user `admin`. The user `admin` has access to more actions that the _anonymous_ user. This simple password can be used only for development and tests. In the case of publishing the service, this file should contain the hashed, secret and strong password.

[source,bash]
----
# Create the password file.
sudo echo -n username-password | shasum -a 512 | awk '{ print $1 }' > /opt/tomcat/sponge/password.txt

# Setup privileges.
cd /opt/tomcat
sudo chown -R tomcat:tomcat sponge

# Restart Tomcat.
sudo systemctl restart tomcat.service
----

Deploy the web application as `sponge-demo-api` using the Tomcat Web Application Manager. Then test the service.

[source,bash]
----
curl -i -k -X POST -H "Content-type:application/json" http://localhost:8080/sponge.json/v1/version
----

[discrete]
===== Running in Jetty
You may also run this example using the Jetty server started by the maven command:

.Example of the REST API servlet
[source,bash,subs="verbatim,attributes"]
----
cd sponge-examples-projects/sponge-examples-project-demo-service
mvn jetty:run
----

[[iot-rpi-service]]
==== IoT on Raspberry Pi
The {sourcesUrl}/sponge-examples-projects/sponge-examples-project-iot-rpi[IoT on Raspberry Pi] project shows how to use {sponge} to read sensors, set actuators, take pictures, send SMS messages, send emails and execute OS commands.

The {sponge} standalone command line application is installed on a Raspberry Pi with a GrovePi extension board. {sponge} provides a synchronous REST API to remotely call actions (that for example change state of actuators). It also sends sensor data (temperature, humidity and light) to an MQTT broker using Apache Camel. The project allows processing sensor data on two levels: locally on the Raspberry Pi edge device by {sponge} (to avoid sending too much data to a management system) or by an external system that connects to the MQTT broker.

[discrete]
===== The hardware

.The sensors and actuators connected to the GrovePi
[cols="2,3"]
|===
|Sensor / actuator |Description

|http://wiki.seeedstudio.com/Grove-TemperatureAndHumidity_Sensor/[DHT sensor] |Connected to the port D2.
|https://www.seeedstudio.com/Grove-Light-Sensor-p-746.html[Light sensor] |Connected to the port A1.
|http://wiki.seeedstudio.com/Grove-Rotary_Angle_Sensor/[Rotary angle sensor] |Connected to the port A0.
|http://wiki.seeedstudio.com/Grove-Sound_Sensor/[Sound sensor] |Connected to the port A2.
|http://wiki.seeedstudio.com/Grove-Red_LED/[Red LED] |Connected to the port D4.
|https://www.seeedstudio.com/Grove-Blue-LED-p-1139.html[Blue LED] |Connected to the port D5.
|http://wiki.seeedstudio.com/Grove-Buzzer/[Buzzer] |Connected to the port D7.
|http://wiki.seeedstudio.com/Grove-LCD_RGB_Backlight/[LCD RGB Backlight] |Connected to the port I2C-1.
|===

.Other hardware connected to the Raspberry Pi
[cols="2,3"]
|===
|Name |Description

|HD Night Vision IR camera |
|Huawei E3131h-2 modem |Connected via a powered USB hub.
|===

[discrete]
===== Prerequisites
The Linux distribution used for this example is Raspbian. All command are invoked by the user `pi`. For SMS sending the `gammu` utility should be installed.

[source,bash]
----
$ sudo apt-get install gammu
----

[discrete]
===== Installation
First you should download and unpack the {sponge} standalone command line application into the `/home/pi/local/app/` directory. The directory `/home/pi/local/app/examples/sponge-iot-rpi` (containing the example knowledge base files) should be copied to `/home/pi/local/` in order to modify the configuration files in a fresh copy.

The preferred installation is as a systemd service.

[source,bash]
----
$ sudo vim /lib/systemd/system/sponge_iot.service
----

[source,bash,subs="verbatim,attributes"]
----
[Unit]
Description=Sponge IoT Service
After=multi-user.target

[Service]
Type=simple
ExecStart=/bin/bash /home/pi/local/app/sponge-{projectVersion}/bin/sponge -c /home/pi/local/sponge-iot-rpi/kb/sponge_iot.xml -Dsponge.home=/home/pi/local/sponge-iot-rpi
WorkingDirectory=/home/pi/local/sponge-iot-rpi/
KillSignal=SIGINT

[Install]
WantedBy=multi-user.target
----

[source,bash]
----
$ sudo chmod 644 /lib/systemd/system/sponge_iot.service
$ sudo systemctl daemon-reload
$ sudo systemctl enable sponge_iot.service
----

[discrete]
===== Configuration
The `sponge_iot.properties` file allows the configuration of the service name, the phone number that will receive SMS notifications, the email address for notifications, the temperature threshold to trigger sending an SMS notification, the email client settings and the MQTT broker settings.

Note that the provided password file `password.txt` stores sample passwords. For each user the password is: password.

[discrete]
===== REST API Actions
The subset of {sponge} actions is published via the {sponge} REST API. The published actions have their metadata configured. These actions could be used by the {sponge} mobile client application to manage the IoT device using a GUI.

.The published actions
[cols="1,4"]
|===
|Name |Description

|SetGrovePiMode |Sets the GrovePi mode (`auto` or `manual`). In the `auto` mode the device behavior is automated according to the following rules. The LCD display shows the current temperature and humidity. The red LED is turned on if there is dark in the room. The blue LED light depends on the position of the rotary angle sensor. The `auto` mode is implemented by triggers and correlators. In the `manual` mode the actuators (LCD, LEDs, etc.) can be managed manually via the published actions.

|ManageLcd |Provides management of the LCD properties, i.e. the display text and color.

|ManageSensorActuatorValues |Provides management of the sensor and actuator values. Reads the temperature and humidity sensor, the light sensor, the rotary angle sensor and the sound sensor. Sets the values of the LEDs and the buzzer.

|TakePicture |Takes a picture using the RPI camera.

|SendNotificationEmail |Sends a notification email to the configured recipient.

|SendNotificationSms |Sends a notification SMS to the configured recipient.

|OsGetDiskSpaceInfo |Executes `df -h` and returns the disk space info as a markdown string.

|OsDmesg |Executes `dmesg` and returns the output as a markdown string.
|===

The REST API uses <<rest-api-server-simple-security-strategy,the simple security strategy>>.

[discrete]
===== MQTT
{sponge} publishes the values of temperature, humidity and light sensors to the MQTT topics `sponge/temperature`, `sponge/humidity` and `sponge/light`. The topic prefix can be changed in the configuration.

[discrete]
===== Modifications in the knowledge bases
After installation, configuration and an initial run you could add your modifications to the knowledge bases. The preferred way to do this is:

* Temporarily stop and disable the {sponge} system service.
* Run {sponge} in an interactive mode in the current console.

[source,bash,subs="verbatim,attributes"]
----
$ cd ~/local/sponge-iot-rpi
$ sudo ~/local/app/sponge-{projectVersion}/bin/sponge -c ~/local/sponge-iot-rpi/kb/sponge_iot.xml -Dsponge.home=. -i iot
----

* Open a new shell console to view logs.

[source,bash,subs="verbatim,attributes"]
----
$ tail -f ~/local/sponge-iot-rpi/logs/sponge-<current_date>.log
----

* Open a new shell console to modify and save the knowledge base files.
* After saving the knowledge base files, reload the knowledge bases in the interactive mode.

[source,bash,subs="verbatim,attributes"]
----
 > sponge.reload()
----

* If the changes require restarting {sponge}, exit the interactive mode (it stops the {sponge} engine) and start {sponge} again.

[source,bash,subs="verbatim,attributes"]
----
 > exit
 $ sudo ~/local/app/sponge-{projectVersion}/bin/sponge -c ~/local/sponge-iot-rpi/kb/sponge_iot.xml -Dsponge.home=. -i iot
----

* If you modify actions and use the {sponge} mobile client application to test the knowledge bases, please remember to refresh the action metadata in the GUI.
* Repeat these steps until your knowledge bases are finished.
* Start and enable the {sponge} system service.

[[mpd-mpc-raspberry]]
==== MPD client service

[discrete]
===== Running in Docker
The Docker image `openksavi/sponge-mpd` contains a predefined {sponge} MPD service that provides a basic set of Music Player Demon (MPD) client related actions. It can be used in combination with the generic {sponge} mobile client application as a simple music player.

The {sponge} MPD service uses the `mpc` client commandline to communicate with the MPD server. For performance reasons the {sponge} MPD service should be installed on the same machine that runs an MPD server.

The main use case is that the service runs in Docker on a Raspberry PI with an already configured MPD. There is a number of Linux distributions for a Raspberry PI that provide well configured music player features. For this example https://volumio.org[Volumio] has been chosen.

The architecture of this solution is: Raspberry PI + MPD server (Volumio) + Docker/{sponge} MPD service.

Installing the {sponge} MPD service:

* https://volumio.org/get-started/[Download], install and configure Volumio for Raspberry PI.
* Enable https://volumio.github.io/docs/User_Manual/SSH.html[SSH].
* Connect to the Raspberry PI via SSH as `volumio` user.
* Install and configure https://howchoo.com/g/nmrlzmq1ymn/how-to-install-docker-on-your-raspberry-pi[Docker].

----
sudo curl -fsSL https://get.docker.com -o get-docker.sh && sh get-docker.sh
sudo usermod -aG docker volumio
----

* Run the {sponge} MPD service in Docker.

----
docker pull openksavi/sponge-mpd
docker run --name sponge-mpd -d --restart always --network host openksavi/sponge-mpd
----

* Check the {sponge} MPD service logs.

----
docker logs sponge-mpd -f
----

Limitations:

* The architecture shown in this example introduces an additional layer between the MPD server and the GUI MPD client (in that case the generic {sponge} mobile client application) that can have a noticable impact on the performance.
* The MPD connection configuration (e.g. the MPD host) is not persisted.

=== Scripting examples
The scripting examples show how to use certain {sponge} functionalities in script knowledge bases. See the sources in {sourcesUrl}/sponge-jython/examples/script/py[Python examples], {sourcesUrl}/sponge-jruby/examples/script/rb[Ruby examples], {sourcesUrl}/sponge-groovy/examples/script/groovy[Groovy examples] and {sourcesUrl}/sponge-nashorn/examples/script/js[JavaScript examples].

Each of these examples is also used in the corresponding JUnit class as a test case with assertions. Note that not all of these examples will work in the standalone application because some of them require additional setup.

.Scripting examples
[cols="1,3"]
|===
|Name |Description

|`actions`
ifdef::useReferences[({pySourcesUrl}/actions.py[py], {rbSourcesUrl}/actions.rb[rb], {groovySourcesUrl}/actions.groovy[groovy], {jsSourcesUrl}/actions.js[js])]
|Shows how to use actions.

|`correlators`
ifdef::useReferences[({pySourcesUrl}/correlators.py[py], {rbSourcesUrl}/correlators.rb[rb], {groovySourcesUrl}/correlators.groovy[groovy], {jsSourcesUrl}/correlators.js[js])]
|Shows how to use correlators. The correlator creates an event log - a list of events that it listens to.

|`correlators_duration`
ifdef::useReferences[({pySourcesUrl}/correlators_duration.py[py], {rbSourcesUrl}/correlators_duration.rb[rb], {groovySourcesUrl}/correlators_duration.groovy[groovy], {jsSourcesUrl}/correlators_duration.js[js])]
|Shows how to use correlators with duration.

|`events_clone_policy`
ifdef::useReferences[({pySourcesUrl}/events_clone_policy.py[py], {rbSourcesUrl}/events_clone_policy.rb[rb], {groovySourcesUrl}/events_clone_policy.groovy[groovy], {jsSourcesUrl}/events_clone_policy.js[js], {pySourcesUrl}/events_clone_policy.xml[XML configuration])]
|Shows event clone policies.

|`events_cron`
ifdef::useReferences[({pySourcesUrl}/events_cron.py[py], {rbSourcesUrl}/events_cron.rb[rb], {groovySourcesUrl}/events_cron.groovy[groovy], {jsSourcesUrl}/events_cron.js[js])]
|Shows sending events using Cron.

|`events_removing`
ifdef::useReferences[({pySourcesUrl}/events_removing.py[py], {rbSourcesUrl}/events_removing.rb[rb], {groovySourcesUrl}/events_removing.groovy[groovy], {jsSourcesUrl}/events_removing.js[js])]
|Shows how to remove scheduled events.

|`filters_deduplication`
ifdef::useReferences[({pySourcesUrl}/filters_deduplication.py[py], {rbSourcesUrl}/filters_deduplication.rb[rb], {groovySourcesUrl}/filters_deduplication.groovy[groovy], {jsSourcesUrl}/filters_deduplication.js[js])]
|Shows how to use a deduplication filter to prevent from processing many events that carry the same information.

|`filters_java`
ifdef::useReferences[({pySourcesUrl}/filters_java.py[py], {rbSourcesUrl}/filters_java.rb[rb], {groovySourcesUrl}/filters_java.groovy[groovy], {jsSourcesUrl}/filters_java.js[js])]
|Shows how to use a Java-based filter.

|`filters`
ifdef::useReferences[({pySourcesUrl}/filters.py[py], {rbSourcesUrl}/filters.rb[rb], {groovySourcesUrl}/filters.groovy[groovy], {jsSourcesUrl}/filters.js[js])]
|Shows how to use script-based filters.

|`actions_hello_world`
ifdef::useReferences[({pySourcesUrl}/actions_hello_world.py[py], {rbSourcesUrl}/actions_hello_world.rb[rb], <{groovySourcesUrl}/actions_hello_world.groovy[groovy], {jsSourcesUrl}/actions_hello_world.js[js], {pySourcesUrl}/actions_hello_world.xml[XML configuration])]
|Hello world action complete example.

|`triggers_hello_world`
ifdef::useReferences[({pySourcesUrl}/triggers_hello_world.py[py], {rbSourcesUrl}/triggers_hello_world.rb[rb], <{groovySourcesUrl}/triggers_hello_world.groovy[groovy], {jsSourcesUrl}/triggers_hello_world.js[js], {pySourcesUrl}/triggers_hello_world.xml[XML configuration])]
|Hello world trigger complete example.

|`knowledge_base_callbacks`
ifdef::useReferences[({pySourcesUrl}/knowledge_base_callbacks.py[py], {rbSourcesUrl}/knowledge_base_callbacks.rb[rb], {groovySourcesUrl}/knowledge_base_callbacks.groovy[groovy], {jsSourcesUrl}/knowledge_base_callbacks.js[js])]
|Shows how to use knowledge base callback functions.

|`knowledge_base_load`
ifdef::useReferences[({pySourcesUrl}/knowledge_base_load.py[py], {rbSourcesUrl}/knowledge_base_load.rb[rb], {groovySourcesUrl}/knowledge_base_load.groovy[groovy], {jsSourcesUrl}/knowledge_base_load.js[js])]
|Shows how to load an additional knowledge base file.

|`knowledge_base_manager`
ifdef::useReferences[({pySourcesUrl}/knowledge_base_manager.py[py], {rbSourcesUrl}/knowledge_base_manager.rb[rb], {groovySourcesUrl}/knowledge_base_manager.groovy[groovy], {jsSourcesUrl}/knowledge_base_manager.js[js])]
|Shows knowledge base operations.

|`library`
ifdef::useReferences[({pySourcesUrl}/library.py[py], {rbSourcesUrl}/library.rb[rb], {groovySourcesUrl}/library.groovy[groovy], {jsSourcesUrl}/library.js[js], {pySourcesUrl}/library.xml[XML configuration])]
|Shows how to use a scripting language specific library (e.g. `httplib` for Python) to check HTTPS host status.

|`plugins_java`
ifdef::useReferences[({pySourcesUrl}/plugins_java.py[py], {rbSourcesUrl}/plugins_java.rb[rb], {groovySourcesUrl}/plugins_java.groovy[groovy], {jsSourcesUrl}/plugins_java.js[js], {pySourcesUrl}/plugins_java.xml[XML configuration])]
|Shows how to define and use a Java-based plugin.

|`plugins_kb`
ifdef::useReferences[({pySourcesUrl}/plugins_kb.py[py], {rbSourcesUrl}/plugins_kb.rb[rb], {groovySourcesUrl}/plugins_kb.groovy[groovy], {jsSourcesUrl}/plugins_kb.js[js], {pySourcesUrl}/plugins_kb.xml[XML configuration])]
|Shows how to define and use a script-based plugin.

|`rules`
ifdef::useReferences[({pySourcesUrl}/rules.py[py], {rbSourcesUrl}/rules.rb[rb], {groovySourcesUrl}/rules.groovy[groovy], {jsSourcesUrl}/rules.js[js])]
|Shows how to define and use ordered rules, i.e. rules listening to ordered sequences of events. Event conditions are specified using lambda expressions as well as class methods.

|`rules_events`
ifdef::useReferences[({pySourcesUrl}/rules_events.py[py], {rbSourcesUrl}/rules_events.rb[rb], {groovySourcesUrl}/rules_events.groovy[groovy], {jsSourcesUrl}/rules_events.js[js], {pySourcesUrl}/rules_events.xml[XML configuration])]
|Shows how to define and use rules that have different event modes, durations etc.

|`rules_heartbeat`
ifdef::useReferences[({pySourcesUrl}/rules_heartbeat.py[py], {rbSourcesUrl}/rules_heartbeat.rb[rb], {groovySourcesUrl}/rules_heartbeat.groovy[groovy], {jsSourcesUrl}/rules_heartbeat.js[js])]
|Heartbeat complete example.

|`rules_none_mode_events_conditions`
ifdef::useReferences[({pySourcesUrl}/rules_none_mode_events_conditions.py[py], {rbSourcesUrl}/rules_none_mode_events_conditions.rb[rb], {groovySourcesUrl}/rules_none_mode_events_conditions.groovy[groovy], {jsSourcesUrl}/rules_none_mode_events_conditions.js[js])]
|Shows how to define and use rules that have `none` event mode and event conditions.

|`rules_none_mode_events`
ifdef::useReferences[({pySourcesUrl}/rules_none_mode_events.py[py], {rbSourcesUrl}/rules_none_mode_events.rb[rb], {groovySourcesUrl}/rules_none_mode_events.groovy[groovy], {jsSourcesUrl}/rules_none_mode_events.js[js])]
|Shows how to define and use rules that have `none` event mode.

|`unordered_rules`
ifdef::useReferences[({pySourcesUrl}/unordered_rules.py[py], {rbSourcesUrl}/unordered_rules.rb[rb], {groovySourcesUrl}/unordered_rules.groovy[groovy], {jsSourcesUrl}/unordered_rules.js[js])]
|Shows how to define and use unordered rules, i.e. rules listening to unordered sequences of events. Event conditions are specified using lambda expressions as well as class methods.

|`triggers`
ifdef::useReferences[({pySourcesUrl}/triggers.py[py], {rbSourcesUrl}/triggers.rb[rb], {groovySourcesUrl}/triggers.groovy[groovy], {jsSourcesUrl}/triggers.js[js], {pySourcesUrl}/triggers.xml[XML configuration])]
|Shows how to define and use triggers.

|`triggers_event_pattern`
ifdef::useReferences[({pySourcesUrl}/triggers_event_pattern.py[py], {rbSourcesUrl}/triggers_event_pattern.rb[rb], {groovySourcesUrl}/triggers_event_pattern.groovy[groovy], {jsSourcesUrl}/triggers_event_pattern.js[js])]
|Shows how to define and use triggers that specify events they listen to as a pattern based on a regular expression.
|===

=== Features examples
The features examples show how to use some of {sponge} features. They are not implemented in all supported scripting languages.

.Features examples
[cols="1,3"]
|===
|Name |Description

|`fibonacci`
ifdef::useReferences[({coreSourcesUrl}/fibonacci.py[py])]
|Shows how to send a chain of events, each carrying a Fibonacci number as an attribute.

|`engine_parameters`
ifdef::useReferences[({coreSourcesUrl}/engine_parameters.xml[xml])]
|Shows how to set engine parameters in the XML configuration file.

|`event_pattern`
ifdef::useReferences[({coreSourcesUrl}/event_pattern.py[py])]
|Shows how to use event name patterns and how to enable/disable processors manually.

|`spring`
ifdef::useReferences[({springSourcesUrl}/spring.py[py], {sourcesUrl}/sponge-spring/src/test/java/org/openksavi/sponge/spring/test/SpringTest.java[java])]
|Shows how to integrate with Spring framework.

|`camel_producer`
ifdef::useReferences[({camelSourcesUrl}/camel_producer.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/SimpleCamelProducerTest.java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger.

|`camel_consumer`
ifdef::useReferences[({camelSourcesUrl}/camel_consumer.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/SimpleCamelConsumerTest.java[java])]
|Shows how to handle messages coming from {sponge} by an Apache Camel route.

|`camel_rss`
ifdef::useReferences[({camelSourcesUrl}/camel_rss.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelRssTest.java[java])]
|Shows how to integrate with Apache Camel to send and handle {sponge} events based on RSS feeds. This example uses a Spring configuration.

|`camel_producer_overridden_action`
ifdef::useReferences[({camelSourcesUrl}/camel_producer_overridden_action.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelProducerOverriddenActionTest.java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger using an overridden Camel producer action.

|`camel_producer_custom_action`
ifdef::useReferences[({camelSourcesUrl}/camel_producer_custom_action.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelProducerCustomActionTest.java[java])]
|Shows how to handle messages coming from Apache Camel route by a {sponge} trigger using a custom Camel producer action.

|`camel_multiple_consumer`
ifdef::useReferences[({camelSourcesUrl}/camel_multiple_consumer.py[py], {sourcesUrl}/sponge-camel/src/test/java/org/openksavi/sponge/camel/test/CamelMultipleConsumerTest.java[java])]
|Shows sending Camel messages to many endpoints in a single {sponge} trigger.

|`py4j_java_server`
ifdef::useReferences[({py4jSourcesUrl}/java_server/py4j_java_server_python_hello_world.py[cpython], {py4jSourcesUrl}/java_server/py4j_java_server_sponge_hello_world.xml[xml], {py4jSourcesUrl}/java_server/py4j_java_server_sponge_hello_world.py[jython])]
|Shows how to integrate with CPython program using Py4J - Java server.

|`py4j_python_server`
ifdef::useReferences[({py4jSourcesUrl}/python_server/py4j_python_server_python_hello_world.py[cpython], {py4jSourcesUrl}/python_server/py4j_python_server_sponge_hello_world.xml[xml], {py4jSourcesUrl}/python_server/py4j_python_server_sponge_hello_world.py[jython], {sourcesUrl}/sponge-py4j/src/test/java/org/openksavi/sponge/py4j/PythonService.java[java])]
|Shows how to integrate with CPython program using Py4J - Python server.

|`py4j_java_server_tls`
ifdef::useReferences[({py4jSourcesUrl}/java_server_tls/py4j_java_server_tls_python_hello_world.py[cpython], {py4jSourcesUrl}/java_server_tls/py4j_java_server_tls_sponge_hello_world.xml[xml], {py4jSourcesUrl}/java_server_tls/py4j_java_server_tls_sponge_hello_world.py[jython])]
|Shows how to integrate with CPython program using Py4J - Java server with TLS security.

|`midi_generate_sound`
ifdef::useReferences[({midiSourcesUrl}/midi_generate_sound.py[py])]
|Shows how to generate MIDI sounds in a {sponge} knowledge base.

|`midi_input`
ifdef::useReferences[({midiSourcesUrl}/midi_input.py[py])]
|Shows how to process MIDI messages created by an external MIDI input device.

|`midi_play_file`
ifdef::useReferences[({midiSourcesUrl}/midi_play_file.py[py])]
|Shows how MIDI messages created by a MIDI sequencer playing a MIDI file could be processed in a {sponge} knowledge base.
|===

=== Standalone examples
The standalone examples show how to use some of {sponge} features in the standalone command-line application.

.Standalone examples
[cols="1,3"]
|===
|Name |Description

|`standalone_news`
ifdef::useReferences[({sourcesUrl}/sponge-standalone/examples/standalone/news[sources])]
|This example is based on complete example project of embedding {sponge} - News, but adjusted to a standalone version.

|`standalone_camel_rss_news`
ifdef::useReferences[({sourcesUrl}/sponge-standalone/examples/standalone/camel_rss_news[sources])]
|This example is based on complete example project of embedding {sponge} - Camel RSS News, but adjusted to a standalone version.

|`camel_route_groovy`
ifdef::useReferences[({sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-groovy[sources])]
|Camel routes in Groovy Spring configuration.

|`camel_route_xml`
ifdef::useReferences[({sourcesUrl}/sponge-examples-projects/sponge-examples-project-standalone-camel-xml[sources])]
|Camel context and routes in XML Spring configuration.
|===

== Maven artifacts
The `groupId` of {sponge} Maven artifacts is `org.openksavi.sponge`.

.{sponge} Maven artifacts
[cols="2,1,5"]
|===
|ArtifactId |Central Maven Repository |Description

|`sponge-parent`
|Yes
|The parent project.

|`sponge-bom`
|Yes
|The Bill Of Materials style pom.xml.

|`sponge-api`
|Yes
|The {sponge} API.

|`sponge-core`
|Yes
|The {sponge} core implementation. This artifact includes a shaded Guava library.

|`sponge-jython`
|Yes
|The support for Python-based scripting knowledge bases using Jython.

|`sponge-jruby`
|Yes
|The support for Ruby-based scripting knowledge bases using JRuby.

|`sponge-groovy`
|Yes
|The support for Groovy-based scripting knowledge bases.

|`sponge-nashorn`
|Yes
|The support for JavaScript-based scripting knowledge bases using Nashorn.

|`sponge-kotlin`
|Yes
|The support for Kotlin-based non scripting knowledge bases.

|`sponge-signal`
|Yes
|The wrappers for Operating System signals.

|`sponge-camel`
|Yes
|The Apache Camel integration.

|`sponge-spring`
|Yes
|The Spring framework integration.

|`sponge-py4j`
|Yes
|The CPython integration that uses Py4J.

|`sponge-midi`
|Yes
|The MIDI integration.

|`sponge-rpi-pi4j`
|Yes
|The Pi4J (for Raspberry Pi) library integration.

|`sponge-reactivex`
|Yes
|The ReactiveX integration.

|`sponge-features`
|Yes
|The predefined action and type features.

|`sponge-rest-api-client`
|Yes
|The Sponge REST API client.

|`sponge-rest-api-server`
|Yes
|The Sponge REST API server.

|`sponge-grpc-api-client`
|Yes
|The Sponge gRPC API client.

|`sponge-grpc-api-server`
|Yes
|The Sponge gRPC API server.

|`sponge-remote-api-server`
|Yes
|The Sponge Remote API server (has dependencies on the REST and the gRPC API servers).

|`sponge-tensorflow`
|Yes
|The TensorFlow integration.

|`sponge-standalone`
|Yes
|The standalone version of {sponge}.

|`sponge-standalone-extensions`
|Yes
|Dependencies for external libraries used by the standalone command-line application.

|`sponge-logging`
|Yes
|The {sponge} logging used by the standalone application.

|`sponge-test`
|Yes
|The {sponge} test support.

|`sponge-rpi-grovepi`
|No
|The GrovePi (for Raspberry Pi) library integration.

|`sponge-examples-projects`
|No
|Complete example projects.

|`sponge-distribution`
|No
|Contains documentation, release configuration, project pages etc.

|`sponge-integration-tests`
|No
|{sponge} integration tests.
|===

include::includes/user-guide-standalone.adoc[leveloffset=+1]

include::includes/user-guide-third-party-software.adoc[leveloffset=+1]
